import numpy as np
import os
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp
from scipy.interpolate import interp1d
from collections import defaultdict

from pygrackle.utilities.physical_constants import sec_per_Myr, cm_per_mpc, mass_hydrogen_cgs
from pygrackle.utilities.data_path import grackle_data_dir
from pygrackle import chemistry_data, setup_fluid_container
from pygrackle.fluid_container import FluidContainer
from pygrackle.utilities.evolve import add_to_data

from physical_constants import cosmo, H0_s, T0_CMB, t_gamma_inv
from utilities import integrate_ode_z
from HaloProperties import get_gas_lognH_analytic
from Yoshida03 import get_K_Tegmark97, get_K_GP98

#Before loading xe_evolution.dat, make sure it has been generated by recombination_camb.py
xe_data_CAMB = np.loadtxt('xe_evolution.dat', skiprows=1)  # Skip first row
z_CAMB = xe_data_CAMB[:, 0]  # First column (redshift)
xe_CAMB = xe_data_CAMB[:, 1]  # Second column (free electron fraction)
xe_interp_func = interp1d(z_CAMB, xe_CAMB)

#Before loading Tgas_evolution.dat, make sure it has been generated by Tgas_evolution_Compton()
Tgas_data = np.loadtxt('Tgas_evolution.dat', skiprows=1)  # Skip first row
z_Tgas = Tgas_data[:, 0]  # First column (redshift)
Tgas = Tgas_data[:, 1]  # Second column (gas temperature)
Tgas_interp_func = interp1d(z_Tgas, Tgas)


def ode_function_Compton_only(z, T):
    Hz = cosmo.Hz(z)/3.086e19  #convert km/s/Mpc to s^(-1)
    xe = xe_interp_func(z) 
    return 2 * T / (1 + z) - xe / (1 + xe + 0.079) * (T0_CMB * (1 + z) - T) * t_gamma_inv * (1 + z) ** 3 / Hz

def Tgas_evolution_Compton():
    #gas temperature evolution including Compton scattering with CMB, use xe(z) from CAMB
    z_start = 1000.0
    z_end = 15.0

    T_zstart = T0_CMB * (1 + z_start)  # Initial temperature at z=1000
    Tgas_result = integrate_ode_z(ode_function_Compton_only,
                             z_start, T_zstart, z_end)


    # Plot the Compton Scattering solution 
    fig = plt.figure(facecolor='white')
    plt.plot(Tgas_result['z'], Tgas_result['y'][0],label='Tgas')
    plt.plot(Tgas_result['z'], np.array(T0_CMB*(1+Tgas_result['z'])), label='CMB', linestyle='--')
    plt.xlabel('1+z')
    plt.ylabel('T(z)')
    plt.xscale('log')
    plt.yscale('log')
    plt.legend()

    plt.title('Temperature Evolution')
    plt.grid(True)
    plt.savefig("Tgas_z.png",dpi=300)

    np.savetxt('Tgas_evolution.dat', np.column_stack([Tgas_result['z'], Tgas_result['y'][0]]), 
           header='Redshift  Tgas[K]', fmt='%.6e')


def get_k_HMphotodiss_H4_GP98(z):
    T_gamma = T0_CMB * (1 + z)
    return 1.1e-1 * T_gamma**2.13 *np.exp(-8823/T_gamma)

def get_k_H2IIphotodiss_H9_GP98(z, model):
    T_gamma = T0_CMB * (1 + z)
    if model == "LTE":
        k = 1.63e7*np.exp(-32400/T_gamma)
    elif model == "v0":
        k = 20*T_gamma**1.59*np.exp(-82000/T_gamma)
    else:
        raise ValueError("Invalid model. Choose 'LTE' or 'v0'.")
    return k
def get_k_H2IIphotodiss_H12_GP98(z):
    T_gamma = T0_CMB * (1 + z)
    return 90*T_gamma**1.48*np.exp(-335000/T_gamma)

"""
def evolve_freefall(fc, final_density, safety_factor=0.01,
                    include_pressure=True):
    my_chemistry = fc.chemistry_data

    # Set units of gravitational constant
    gravitational_constant = (
        4.0 * np.pi * gravitational_constant_cgs *
        my_chemistry.density_units * my_chemistry.time_units**2)

    # some constants for the analytical free-fall solution
    freefall_time_constant = np.power(((32. * gravitational_constant) /
                                       (3. * np.pi)), 0.5)

    data = defaultdict(list)
    current_time = 0.0
    while fc["density"][0] * my_chemistry.density_units < final_density:
        # calculate timestep based on free-fall solution
        dt = safety_factor * \
          np.power(((3. * np.pi) /
                    (32. * gravitational_constant *
                     fc["density"][0])), 0.5)

        add_to_data(fc, data, extra={"time": current_time})

        # compute the new density using the modified
        # free-fall collapse as per Omukai et al. (2005)
        if include_pressure:
            force_factor = calculate_collapse_factor(data["pressure"], data["density"])
        else:
            force_factor = 0.
        data["force_factor"].append(force_factor)

        # calculate new density from altered free-fall solution
        new_density = np.power((np.power(fc["density"][0], -0.5) -
                                (0.5 * freefall_time_constant * dt *
                                 np.power((1 - force_factor), 0.5))), -2.)

        print("Evolve Freefall - t: %e yr, rho: %e g/cm^3, T: %e K." %
              ((current_time * my_chemistry.time_units / sec_per_year),
               (fc["density"][0] * my_chemistry.density_units),
               fc["temperature"][0]))

        # use this to multiply by elemental densities if you are tracking those
        density_ratio = new_density / fc["density"][0]

        # update densities
        for field in fc.density_fields:
            fc[field] *= density_ratio

        # now update energy for adiabatic heating from collapse
        fc["internal_energy"][0] += (my_chemistry.Gamma - 1.) * \
          fc["internal_energy"][0] * freefall_time_constant * \
          np.power(fc["density"][0], 0.5) * dt

        fc.solve_chemistry(dt)

        # update time
        current_time += dt

    for field in data:
        data[field] = np.squeeze(np.array(data[field]))
    return fc.finalize_data(data=data)

def evolve_constant_density(fc, final_temperature=None,
                            final_time=None, safety_factor=0.01):
    my_chemistry = fc.chemistry_data

    if final_temperature is None and final_time is None:
        raise RuntimeError("Must specify either final_temperature " +
                           "or final_time.")

    data = defaultdict(list)
    current_time = 0.0
    fc.calculate_cooling_time()
    dt = safety_factor * np.abs(fc["cooling_time"][0])
    fc.calculate_temperature()
    while True:
        if final_temperature is not None and fc["temperature"][0] <= final_temperature:
            break
        if final_time is not None and current_time >= final_time:
            break

        fc.calculate_temperature()
        print("Evolve constant density - t: %e yr, rho: %e g/cm^3, T: %e K." %
              (current_time * my_chemistry.time_units / sec_per_year,
               fc["density"][0] * my_chemistry.density_units,
               fc["temperature"][0]))
        fc.solve_chemistry(dt)
        add_to_data(fc, data, extra={"time": current_time})
        current_time += dt

    for field in data:
        data[field] = np.squeeze(np.array(data[field]))
    return fc.finalize_data(data=data)

"""
def get_nH_T_in_halo(z, z_vir, T_vir):
    if z >= z_vir:
        T= Tgas_interp_func(z) 
        lognH_analytic = get_gas_lognH_analytic(z)
        nH = 10.**lognH_analytic/200 #use average baryonic density instead of 200x
    else:
        T = T_vir  
        lognH_analytic = get_gas_lognH_analytic(z)
        nH = 10.**lognH_analytic #assume 200 times critical density in halo
    return nH, T


    

def run_grackle_cosmic_chemistry(initial_redshift, final_redshift, z_vir, T_vir):
    """
    initial_redshift - z_vir: set density to baryonic density; T = Tgas(z)
    z_vir - final_redshift: set density to 200 * baryonic critical density; T = T_vir
    """
    print(f"Running Grackle cosmic chemistry... Initial redshift: {initial_redshift}, Final redshift: {final_redshift}, z_vir: {z_vir}, T_vir: {T_vir}")

    # Just run the script as is.
    metallicity = 0.
    # dictionary to store extra information in output dataset
    extra_attrs = {}

    # Set solver parameters
    my_chemistry = chemistry_data()
    my_chemistry.use_grackle = 1
    my_chemistry.with_radiative_cooling = 0  #directly set gas temperature according to Galli&Palla 1998
    my_chemistry.primordial_chemistry = 3
    my_chemistry.metal_cooling = 0
    my_chemistry.dust_chemistry = 0
    my_chemistry.photoelectric_heating = 0
    my_chemistry.self_shielding_method = 0
    my_chemistry.H2_self_shielding = 0
    my_chemistry.CaseBRecombination = 0 #debug, now use Case B recombination to exclude direct recombination to ground state
    my_chemistry.cie_cooling = 1   #Flag to enable H2 collision-induced emission cooling from Ripamonti & Abel (2004).
    my_chemistry.h2_optical_depth_approximation = 1  # H2 cooling attenuation from Ripamonti & Abel (2004)
    my_chemistry.grackle_data_file = os.path.join(
        grackle_data_dir, "cloudy_metals_2008_3D.h5")
    print("Using grackle data file: ", my_chemistry.grackle_data_file)
    my_chemistry.use_volumetric_heating_rate = 0
    my_chemistry.UVbackground = 0 #
    my_chemistry.LWbackground_intensity = 0.0  # no LW background


    # Set units
    my_chemistry.comoving_coordinates = 0 #use proper units for now
    my_chemistry.a_units = 1.0
    my_chemistry.a_value = 1. / (1.0) / my_chemistry.a_units  #do not use comoving coordinates now
    my_chemistry.density_units  = mass_hydrogen_cgs
    my_chemistry.length_units   = cm_per_mpc
    my_chemistry.time_units     = sec_per_Myr
    my_chemistry.set_velocity_units()


    #Set up initial conditions
    initial_nH, initial_temperature = get_nH_T_in_halo(initial_redshift, z_vir, T_vir)
    initial_density     = initial_nH * mass_hydrogen_cgs # g / cm^3
    initial_xe = xe_interp_func(initial_redshift) #debug

    if initial_redshift == 100:
        initial_H2 = 1.0e-6
        initial_H2II = 1.0e-13
        initial_HM = 1.0e-11
    elif initial_redshift == 300:
        initial_H2 = 2*1.0e-7  #initial H2 mass fraction (~1e-7 at z = 300, see [H2/H] abundance in Galli & Palla 1998)
        initial_H2II = 2*1.0e-12  #initial H2+ mass fraction
        initial_HM = 1.0e-20  #initial H2- mass fraction
    elif initial_redshift == 1000:
        initial_H2 = 2*1.0e-13
        initial_H2II = 2*1.0e-18
        initial_HM = 1.0e-19
    else:
        raise ValueError("Unsupported initial redshift. Supported values are 300 and 1000.")

    metal_mass_fraction = metallicity * my_chemistry.SolarMetalFractionByMass
    dust_to_gas_ratio = metallicity * my_chemistry.local_dust_to_gas_ratio

    # fc = setup_fluid_container(
    #     my_chemistry,
    #     density=initial_density,
    #     temperature=initial_temperature,
    #     metal_mass_fraction=metal_mass_fraction,
    #     dust_to_gas_ratio=dust_to_gas_ratio,
    #     state="neutral",
    #     converge=False)
    
    # print("length units:", my_chemistry.length_units)
    # print("density units:", my_chemistry.density_units)
    # print("time units:", my_chemistry.time_units)
    # print("a_value:", my_chemistry.a_value)
    # print("a_units:", my_chemistry.a_units)
    rval = my_chemistry.initialize()
    co_length_units = my_chemistry.length_units*my_chemistry.a_value*my_chemistry.a_units
    # print("co_length_units:", co_length_units)
    co_density_units = my_chemistry.density_units / (my_chemistry.a_value * my_chemistry.a_units)**3
    # print("co_density_units:", co_density_units)
    timeBase1 = my_chemistry.time_units
    lengthBase1 = co_length_units / (my_chemistry.a_value*my_chemistry.a_units)
    densityBase1 = co_density_units * (my_chemistry.a_value * my_chemistry.a_units)**3
    kUnit = my_chemistry.a_units**3 * mass_hydrogen_cgs /(densityBase1 * timeBase1)
    kUnit_3Bdy = kUnit * my_chemistry.a_units**3 * mass_hydrogen_cgs / densityBase1
    coolingUnits =  my_chemistry.a_units**5 * lengthBase1**2 * mass_hydrogen_cgs**2 / (densityBase1 * timeBase1**3)


    # print("kUnit:", kUnit)

    if rval == 0:
        raise RuntimeError("Failed to initialize chemistry_data.")

    tiny_number = 1e-20
    if metal_mass_fraction is None:
        metal_mass_fraction = tiny_number
    if dust_to_gas_ratio is None:
        dust_to_gas_ratio = tiny_number
    
    temperature = initial_temperature
    if not isinstance(temperature, np.ndarray):
        temperature = np.array([temperature])
        print("initial_temperature is not an array, converting to array.")
    n_points = temperature.size

    fc = FluidContainer(my_chemistry, n_points)

    fh = my_chemistry.HydrogenFractionByMass
    d2h = my_chemistry.DeuteriumToHydrogenRatio

    metal_free = 1 - metal_mass_fraction
    H_total = fh * metal_free
    He_total = (1 - fh) * metal_free
    # someday, maybe we'll include D in the total
    D_total = H_total * d2h

    fc_density = initial_density / my_chemistry.density_units
    tiny_density = tiny_number * fc_density

    state_vals = {
        "density": fc_density,
        "metal_density": metal_mass_fraction * fc_density,
        "dust_density": dust_to_gas_ratio * fc_density
    }

    # if state == "neutral":
    state_vals["HI_density"] = H_total * fc_density
    state_vals["HeI_density"] = He_total * fc_density
    state_vals["DI_density"] = D_total * fc_density

    # print("initial He mass fraction", He_total)
    # print("initial H mass fraction", H_total)
    # print("initial D mass fraction", D_total)

    state_vals["HII_density"] = initial_xe * fc_density  #initial H+ (mass) fraction
    state_vals["HeIII_density"] = tiny_density  
    state_vals["e_density"] = state_vals["HII_density"] + state_vals["HeIII_density"] / 2 #initial free electron number density
    state_vals["H2I_density"] = initial_H2 * fc_density #initial H2 mass fraction
    state_vals["H2II_density"] = initial_H2II * fc_density  #initial H2+ mass fraction
    state_vals["HM_density"] = initial_HM * fc_density  #initial H2- mass fraction

    # print("initial H+ mass fraction", initial_xe)
    # print("initial H2 mass fraction", initial_H2)
    # print("initial H2+ mass fraction", initial_H2II)
    # print("initial H- mass fraction", initial_HM)


    for field in fc.density_fields:
        fc[field][:] = state_vals.get(field, tiny_density)

    fc.calculate_mean_molecular_weight()
    fc["internal_energy"] = temperature / \
        fc.chemistry_data.temperature_units / \
        fc["mean_molecular_weight"] / (my_chemistry.Gamma - 1.0)
    fc["x_velocity"][:] = 0.0
    fc["y_velocity"][:] = 0.0
    fc["z_velocity"][:] = 0.0


    #evolve the gas from initial redshift to final redshift
    current_redshift = initial_redshift
    if current_redshift >= 500:
        current_time = 0.0
    else:
        current_time = cosmo.age(current_redshift)*1e3 # convert from Gyr to Myr
    data = defaultdict(list)
    count = 0
    kRadUnit = 1/my_chemistry.time_units  

    while current_redshift > final_redshift:
        count += 1
        print(f"Step {count}:")
        print(f"Redshift: {current_redshift}, Time: {current_time:.2f} Myr")
        dz = -0.01 * current_redshift  # step size
        Hz = cosmo.Hz(current_redshift)/3.086e19  #convert km/s/Mpc to s^(-1)
        dt_dz = -1/(1+current_redshift)/Hz
        dtMyr_dz = dt_dz / my_chemistry.time_units  # convert to Myr
        dtMyr = dtMyr_dz * dz
        dtsec = dtMyr * sec_per_Myr  # convert to seconds
        # fc.calculate_cooling_time()
        # dt_cooling = 0.01 * np.abs(fc["cooling_time"][0])  # cooling time in Myr
        # print(f"dtMyr: {dtMyr:.2f}, dz: {dz:.2f}, dt_cooling: {dt_cooling:.2f} Myr")




        add_to_data(fc, data, extra={"time": current_time, "redshift": current_redshift})
        new_nH, new_temperature = get_nH_T_in_halo(current_redshift, z_vir, T_vir)
        new_density = new_nH * mass_hydrogen_cgs
        density_ratio = new_density / (fc["density"][0] * my_chemistry.density_units)
        # update densities
        for field in fc.density_fields:
            fc[field] *= density_ratio

        fc.calculate_mean_molecular_weight()
        fc["internal_energy"] = new_temperature / \
        fc.chemistry_data.temperature_units / \
        fc["mean_molecular_weight"] / (my_chemistry.Gamma - 1.0)

        #manuually set the radiative reaction rates
        # fc.chemistry_data.k27 = get_K_Tegmark97(4, np.nan, current_redshift) / kRadUnit
        # fc.chemistry_data.k28 = get_K_Tegmark97(7, np.nan, current_redshift) / kRadUnit
        
        fc.chemistry_data.k24 = get_K_GP98("H2", current_redshift) / kRadUnit
        fc.chemistry_data.k25 = get_K_GP98("He2", current_redshift) / kRadUnit
        fc.chemistry_data.k26 = get_K_GP98("He4", current_redshift) / kRadUnit
        fc.chemistry_data.k27 = get_K_GP98("H4", current_redshift) / kRadUnit
        fc.chemistry_data.k28 = get_K_GP98("H9LTE", current_redshift) / kRadUnit
        fc.chemistry_data.k29 = get_K_GP98("H18", current_redshift) / kRadUnit
        fc.chemistry_data.k30 = get_K_GP98("H12", current_redshift) / kRadUnit

        fc.solve_chemistry(dtMyr)

        current_redshift += dz
        current_time += dtMyr

    for field in data:
        data[field] = np.squeeze(np.array(data[field]))
        


    # print("k1:", my_chemistry.k1)
    # print("shape of k1:", my_chemistry.k1.shape)
    # print("k28:",my_chemistry.k28)
    # let the gas cool at constant density from the starting temperature
    # down to a lower temperature to get the species fractions in a
    # reasonable state.
    # data0 = evolve_constant_density(
    #     fc, final_temperature=cooling_temperature,
    #     safety_factor=0.1)
    #debug: different H2 fractions
    # fc["H2I_density"][:] = fc["density"][:]*1.0e-6
    # print(data0['time'].in_units('Myr'))  
    # print(data0["H2I_density"] / data0["density"])

    # if my_chemistry.use_volumetric_heating_rate:
    #     fc["volumetric_heating_rate"][:] = volumetric_heating_rate


    k2_data = np.array(fc.chemistry_data.k2, copy=True)
    reaction_rates = {
        'k2': k2_data,
        'kUnit': kUnit,
    }
    return data

def plot_global_species_mass_fraction(data,filename):
    species_keys = ['e_density', 'HI_density', 'HII_density',
                    'H2I_density', 'H2II_density', 'HM_density']
    fig, ax = plt.subplots(figsize=(8, 6))
    for key in species_keys:
        if key in data:
            ax.plot(data['redshift'], data[key] / data['density'], label=key)
    ax.invert_xaxis()
    ax.set_ylim(1e-20,10)
    ax.set_xscale('log')
    ax.set_yscale('log')
    ax.set_xlabel('Redshift (z)', fontsize=14)
    ax.set_ylabel('Mass Fraction', fontsize=14)
    ax.grid()
    ax.legend()
    plt.tight_layout()
    plt.savefig(filename, dpi=300)
    plt.close(fig)

def debug_k2_Grackle(T):
    return 4.881357e-6*T**(-1.5)* (1+1.14813e2*T**(-0.407))**(-2.242)

if __name__ == "__main__":

    #1. plot xe(z) across redshift
    data = run_grackle_cosmic_chemistry(initial_redshift=100, final_redshift=15, z_vir=-1, T_vir=np.nan)
    
    # print("Final data keys:", data.keys())
    # print(data['time'])

    fig, ax = plt.subplots(figsize=(8, 6))
    CAMB_mask = (z_CAMB > 15) & (z_CAMB < 1800)
    ax.plot(z_CAMB[CAMB_mask], xe_CAMB[CAMB_mask], label='CAMB data', color='k', linestyle='-')
    ax.plot(data['redshift'], data['e_density']/data['density'], label='Grackle', color='b', linestyle='--')

    ax.invert_xaxis()
    ax.set_xscale('log')
    ax.set_yscale('log')
    ax.set_xlabel('Redshift (z)', fontsize=14)
    ax.set_ylabel('Ionization Fraction (xe)', fontsize=14)
    ax.grid()
    ax.legend()
    plt.tight_layout()
    filename = os.path.join("Grackle_cosmic_chemistry_results", f"global_xe_vs_z.png")
    plt.savefig(filename, dpi=300)


    #1.2 plot all mass fractions vs z
    plot_global_species_mass_fraction(data, os.path.join("Grackle_cosmic_chemistry_results", "global_species_mass_fraction_vs_z.png"))

    #1.3 debug k2, k27, k28 rates
    TemperatureStart = 1.0
    TemperatureEnd = 1.0e9
    NumberOfTemperatureBins = 600
    log_Tstart = np.log(TemperatureStart)
    d_logT = (np.log(TemperatureEnd) - log_Tstart) / (NumberOfTemperatureBins  - 1)
    logT_list = log_Tstart + np.arange(NumberOfTemperatureBins) * d_logT
    T_list = np.exp(logT_list)

    K1_Tegmark97 = get_K_Tegmark97(1, T_list, 0)
    k2_debug = debug_k2_Grackle(T_list)
    


    # fig, ax = plt.subplots(figsize=(8, 6))
    # ax.plot(T_list, reaction_rates['k2']*reaction_rates['kUnit'], color='b', linestyle='-', label='H+ recombination, Grackle')
    # ax.plot(T_list, k2_debug, color='g', linestyle=':', label='H+ recombination, debug Grackle')
    # ax.plot(T_list, K1_Tegmark97, color='r', linestyle='--', label='H+ recombination, Tegmark 1997')
    # ax.set_xscale('log')
    # ax.set_yscale('log')
    # ax.set_xlabel('Temperature (K)', fontsize=14)
    # ax.set_ylabel('rate (cm^3/s or /s)', fontsize=14)
    # ax.grid()
    # ax.legend()
    # plt.tight_layout()
    # filename = os.path.join("Grackle_cosmic_chemistry_results", f"debug_k_vs_T.png")
    # plt.savefig(filename, dpi=300)

    
    

    #2.1 plot fH2(z) for zvir_list and Tvir_list
    Tvir_list = [100, 1000, 3000]
    zvir_list = [20, 50, 100]
    colors = ['b', 'g', 'r']
    linestyles = ["--", ":", '-']
    data_all = []
    for T_vir in Tvir_list:
        for z_vir in zvir_list:
            data = run_grackle_cosmic_chemistry(initial_redshift=100, final_redshift=15, z_vir=z_vir, T_vir=T_vir)
            data_all.append(data)

    fig, ax = plt.subplots(figsize=(8, 6))
    for i in range(len(Tvir_list)):
        for j in range(len(zvir_list)):
            data = data_all[i * len(zvir_list) + j]
            ax.plot(data['redshift'], data['H2I_density']/data['density'], 
                    label=f'T_vir={Tvir_list[i]} K, z_vir={zvir_list[j]}', 
                    color=colors[i], linestyle=linestyles[j])
    ax.invert_xaxis()
    ax.set_xscale('log')
    ax.set_yscale('log')
    ax.set_xlabel('Redshift (z)', fontsize=14)
    ax.set_ylabel('H2 Mass Fraction (fH2)', fontsize=14)
    ax.grid()
    ax.legend()
    plt.tight_layout()
    filename = os.path.join("Grackle_cosmic_chemistry_results", f"fH2_vs_z.png")
    plt.savefig(filename, dpi=300)

    #2.2 plot xe(z) for zvir_list and Tvir_list
    fig, ax = plt.subplots(figsize=(8, 6))
    for i in range(len(Tvir_list)):
        for j in range(len(zvir_list)):
            data = data_all[i * len(zvir_list) + j]
            ax.plot(data['redshift'], data['e_density']/data['density'],
                    label=f'T_vir={Tvir_list[i]} K, z_vir={zvir_list[j]}',
                    color=colors[i], linestyle=linestyles[j])
    ax.invert_xaxis()
    ax.set_xscale('log')
    ax.set_yscale('log')
    ax.set_xlabel('Redshift (z)', fontsize=14)
    ax.set_ylabel('Ionization Fraction (xe)', fontsize=14)
    ax.grid()
    ax.legend()
    plt.tight_layout()
    filename = os.path.join("Grackle_cosmic_chemistry_results", f"xe_vs_z.png")
    plt.savefig(filename, dpi=300)

    #2.3 plot H- (HM) fraction vs z for different Tvir and zvir
    fig, ax = plt.subplots(figsize=(8, 6))
    for i in range(len(Tvir_list)):
        for j in range(len(zvir_list)):
            data = data_all[i * len(zvir_list) + j]
            ax.plot(data['redshift'], data['HM_density']/data['density'],
                    label=f'T_vir={Tvir_list[i]} K, z_vir={zvir_list[j]}',
                    color=colors[i], linestyle=linestyles[j])
    ax.invert_xaxis()
    ax.set_xscale('log')
    ax.set_yscale('log')
    ax.set_xlabel('Redshift (z)', fontsize=14)
    ax.set_ylabel('H- Mass Fraction (HM)', fontsize=14)
    ax.grid()
    ax.legend()
    plt.tight_layout()
    filename = os.path.join("Grackle_cosmic_chemistry_results", f"HM_vs_z.png")
    plt.savefig(filename, dpi=300)

    #2.4 plot H2+ fraction vs z for different Tvir and zvir
    fig, ax = plt.subplots(figsize=(8, 6))
    for i in range(len(Tvir_list)):
        for j in range(len(zvir_list)):
            data = data_all[i * len(zvir_list) + j]
            ax.plot(data['redshift'], data['H2II_density']/data['density'],
                    label=f'T_vir={Tvir_list[i]} K, z_vir={zvir_list[j]}',
                    color=colors[i], linestyle=linestyles[j])
    ax.invert_xaxis()
    ax.set_xscale('log')
    ax.set_yscale('log')
    ax.set_xlabel('Redshift (z)', fontsize=14)
    ax.set_ylabel('H2+ mass fraction', fontsize=14)
    ax.grid()
    ax.legend()
    plt.tight_layout()
    filename = os.path.join("Grackle_cosmic_chemistry_results", f"H2II_vs_z.png")
    plt.savefig(filename, dpi=300)


    #3. plot final fH2 vs Tvir for different zvir at z = 17
    z_final = 17
    zvir_list = [20, 50, 100]
    Tvir_fulllist = np.logspace(np.log10(100), np.log10(8000), 50) 
    fH2_final = np.zeros((len(zvir_list), len(Tvir_fulllist)))
    for i, z_vir in enumerate(zvir_list):
        for j, T_vir in enumerate(Tvir_fulllist):
            data = run_grackle_cosmic_chemistry(initial_redshift=100, final_redshift=z_final, z_vir=z_vir, T_vir=T_vir)
            fH2_final[i, j] = data['H2I_density'][-1] / data['density'][-1]
    
    fig, ax = plt.subplots(figsize=(8, 6))
    for i, z_vir in enumerate(zvir_list):
        ax.plot(Tvir_fulllist, fH2_final[i], label=f'z_vir={z_vir}', color='k', linestyle=linestyles[i])
    ax.set_xlabel('T_vir [K]', fontsize=14)
    ax.set_ylabel(f'H2 Mass Fraction at z = {z_final}', fontsize=14)
    ax.set_xscale('log')
    ax.set_yscale('log')
    ax.grid()
    ax.legend()
    plt.tight_layout()
    filename = os.path.join("Grackle_cosmic_chemistry_results", f"fH2_vs_Tvir_z{z_final}.png")
    plt.savefig(filename, dpi=300)
    