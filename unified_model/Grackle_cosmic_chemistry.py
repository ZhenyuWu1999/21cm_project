import numpy as np
import os
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp
from scipy.interpolate import interp1d
from collections import defaultdict

from pygrackle.utilities.physical_constants import sec_per_Myr, cm_per_mpc, mass_hydrogen_cgs
from pygrackle.utilities.data_path import grackle_data_dir
from pygrackle import chemistry_data, setup_fluid_container
from pygrackle.fluid_container import FluidContainer
from pygrackle.utilities.evolve import add_to_data

from physical_constants import cosmo, H0_s, T0_CMB, t_gamma_inv
from utilities import integrate_ode_z
from HaloProperties import get_gas_lognH_analytic

#Before loading xe_evolution.dat, make sure it has been generated by recombination_camb.py
xe_data_CAMB = np.loadtxt('xe_evolution.dat', skiprows=1)  # Skip first row
z_CAMB = xe_data_CAMB[:, 0]  # First column (redshift)
xe_CAMB = xe_data_CAMB[:, 1]  # Second column (free electron fraction)
xe_interp_func = interp1d(z_CAMB, xe_CAMB)

#Before loading Tgas_evolution.dat, make sure it has been generated by Tgas_evolution_Compton()
Tgas_data = np.loadtxt('Tgas_evolution.dat', skiprows=1)  # Skip first row
z_Tgas = Tgas_data[:, 0]  # First column (redshift)
Tgas = Tgas_data[:, 1]  # Second column (gas temperature)
Tgas_interp_func = interp1d(z_Tgas, Tgas)


def ode_function_Compton_only(z, T):
    Hz = cosmo.Hz(z)/3.086e19  #convert km/s/Mpc to s^(-1)
    xe = xe_interp_func(z) 
    return 2 * T / (1 + z) - xe / (1 + xe + 0.079) * (T0_CMB * (1 + z) - T) * t_gamma_inv * (1 + z) ** 3 / Hz

def Tgas_evolution_Compton():
    #gas temperature evolution including Compton scattering with CMB, use xe(z) from CAMB
    z_start = 1000.0
    z_end = 15.0

    T_zstart = T0_CMB * (1 + z_start)  # Initial temperature at z=1000
    Tgas_result = integrate_ode_z(ode_function_Compton_only,
                             z_start, T_zstart, z_end)


    # Plot the Compton Scattering solution 
    fig = plt.figure(facecolor='white')
    plt.plot(Tgas_result['z'], Tgas_result['y'][0],label='Tgas')
    plt.plot(Tgas_result['z'], np.array(T0_CMB*(1+Tgas_result['z'])), label='CMB', linestyle='--')
    plt.xlabel('1+z')
    plt.ylabel('T(z)')
    plt.xscale('log')
    plt.yscale('log')
    plt.legend()

    plt.title('Temperature Evolution')
    plt.grid(True)
    plt.savefig("Tgas_z.png",dpi=300)

    np.savetxt('Tgas_evolution.dat', np.column_stack([Tgas_result['z'], Tgas_result['y'][0]]), 
           header='Redshift  Tgas[K]', fmt='%.6e')




"""
def evolve_freefall(fc, final_density, safety_factor=0.01,
                    include_pressure=True):
    my_chemistry = fc.chemistry_data

    # Set units of gravitational constant
    gravitational_constant = (
        4.0 * np.pi * gravitational_constant_cgs *
        my_chemistry.density_units * my_chemistry.time_units**2)

    # some constants for the analytical free-fall solution
    freefall_time_constant = np.power(((32. * gravitational_constant) /
                                       (3. * np.pi)), 0.5)

    data = defaultdict(list)
    current_time = 0.0
    while fc["density"][0] * my_chemistry.density_units < final_density:
        # calculate timestep based on free-fall solution
        dt = safety_factor * \
          np.power(((3. * np.pi) /
                    (32. * gravitational_constant *
                     fc["density"][0])), 0.5)

        add_to_data(fc, data, extra={"time": current_time})

        # compute the new density using the modified
        # free-fall collapse as per Omukai et al. (2005)
        if include_pressure:
            force_factor = calculate_collapse_factor(data["pressure"], data["density"])
        else:
            force_factor = 0.
        data["force_factor"].append(force_factor)

        # calculate new density from altered free-fall solution
        new_density = np.power((np.power(fc["density"][0], -0.5) -
                                (0.5 * freefall_time_constant * dt *
                                 np.power((1 - force_factor), 0.5))), -2.)

        print("Evolve Freefall - t: %e yr, rho: %e g/cm^3, T: %e K." %
              ((current_time * my_chemistry.time_units / sec_per_year),
               (fc["density"][0] * my_chemistry.density_units),
               fc["temperature"][0]))

        # use this to multiply by elemental densities if you are tracking those
        density_ratio = new_density / fc["density"][0]

        # update densities
        for field in fc.density_fields:
            fc[field] *= density_ratio

        # now update energy for adiabatic heating from collapse
        fc["internal_energy"][0] += (my_chemistry.Gamma - 1.) * \
          fc["internal_energy"][0] * freefall_time_constant * \
          np.power(fc["density"][0], 0.5) * dt

        fc.solve_chemistry(dt)

        # update time
        current_time += dt

    for field in data:
        data[field] = np.squeeze(np.array(data[field]))
    return fc.finalize_data(data=data)

def evolve_constant_density(fc, final_temperature=None,
                            final_time=None, safety_factor=0.01):
    my_chemistry = fc.chemistry_data

    if final_temperature is None and final_time is None:
        raise RuntimeError("Must specify either final_temperature " +
                           "or final_time.")

    data = defaultdict(list)
    current_time = 0.0
    fc.calculate_cooling_time()
    dt = safety_factor * np.abs(fc["cooling_time"][0])
    fc.calculate_temperature()
    while True:
        if final_temperature is not None and fc["temperature"][0] <= final_temperature:
            break
        if final_time is not None and current_time >= final_time:
            break

        fc.calculate_temperature()
        print("Evolve constant density - t: %e yr, rho: %e g/cm^3, T: %e K." %
              (current_time * my_chemistry.time_units / sec_per_year,
               fc["density"][0] * my_chemistry.density_units,
               fc["temperature"][0]))
        fc.solve_chemistry(dt)
        add_to_data(fc, data, extra={"time": current_time})
        current_time += dt

    for field in data:
        data[field] = np.squeeze(np.array(data[field]))
    return fc.finalize_data(data=data)

"""
def get_nH_T_in_halo(z, z_vir, T_vir):
    if z >= z_vir:
        T= Tgas_interp_func(z) 
        lognH_analytic = get_gas_lognH_analytic(z)
        nH = 10.**lognH_analytic/200 #use average baryonic density instead of 200x
    else:
        T = T_vir
        lognH_analytic = get_gas_lognH_analytic(z)
        nH = 10.**lognH_analytic #assume 200 times critical density in halo
    return nH, T


    

def run_grackle_cosmic_chemistry(initial_redshift, final_redshift, z_vir, T_vir):
    """
    initial_redshift - z_vir: set density to baryonic density; T = Tgas(z)
    z_vir - final_redshift: set density to 200 * baryonic critical density; T = T_vir
    """

    # Just run the script as is.
    metallicity = 0.
    # dictionary to store extra information in output dataset
    extra_attrs = {}

    # Set solver parameters
    my_chemistry = chemistry_data()
    my_chemistry.use_grackle = 1
    my_chemistry.with_radiative_cooling = 0  #directly set gas temperature according to Galli&Palla 1998
    my_chemistry.primordial_chemistry = 3
    my_chemistry.metal_cooling = 0
    my_chemistry.dust_chemistry = 0
    my_chemistry.photoelectric_heating = 0
    my_chemistry.self_shielding_method = 0
    my_chemistry.H2_self_shielding = 0
    my_chemistry.CaseBRecombination = 1 #now use Case B recombination to exclude direct recombination to ground state
    my_chemistry.cie_cooling = 1   #Flag to enable H2 collision-induced emission cooling from Ripamonti & Abel (2004).
    my_chemistry.h2_optical_depth_approximation = 1  # H2 cooling attenuation from Ripamonti & Abel (2004)
    my_chemistry.grackle_data_file = os.path.join(
        grackle_data_dir, "cloudy_metals_2008_3D.h5")
    print("Using grackle data file: ", my_chemistry.grackle_data_file)
    my_chemistry.use_volumetric_heating_rate = 0
    my_chemistry.LWbackground_intensity = 0.0  # no LW background


    # Set units
    my_chemistry.comoving_coordinates = 0 #use proper units for now
    my_chemistry.a_units = 1.0
    my_chemistry.a_value = 1. / (1.0) / my_chemistry.a_units  #do not use comoving coordinates now
    my_chemistry.density_units  = mass_hydrogen_cgs
    my_chemistry.length_units   = cm_per_mpc
    my_chemistry.time_units     = sec_per_Myr
    my_chemistry.set_velocity_units()


    #Set up initial conditions
    initial_nH, initial_temperature = get_nH_T_in_halo(initial_redshift, z_vir, T_vir)
    initial_xe = xe_interp_func(initial_redshift)
    initial_fH2 = 1.0e-7
    initial_density     = initial_nH * mass_hydrogen_cgs # g / cm^3

    metal_mass_fraction = metallicity * my_chemistry.SolarMetalFractionByMass
    dust_to_gas_ratio = metallicity * my_chemistry.local_dust_to_gas_ratio

    # fc = setup_fluid_container(
    #     my_chemistry,
    #     density=initial_density,
    #     temperature=initial_temperature,
    #     metal_mass_fraction=metal_mass_fraction,
    #     dust_to_gas_ratio=dust_to_gas_ratio,
    #     state="neutral",
    #     converge=False)
    

    rval = my_chemistry.initialize()
    if rval == 0:
        raise RuntimeError("Failed to initialize chemistry_data.")

    tiny_number = 1e-20
    if metal_mass_fraction is None:
        metal_mass_fraction = tiny_number
    if dust_to_gas_ratio is None:
        dust_to_gas_ratio = tiny_number
    
    temperature = initial_temperature
    if not isinstance(temperature, np.ndarray):
        temperature = np.array([temperature])
        print("initial_temperature is not an array, converting to array.")
    n_points = temperature.size

    fc = FluidContainer(my_chemistry, n_points)
    fh = my_chemistry.HydrogenFractionByMass
    d2h = my_chemistry.DeuteriumToHydrogenRatio

    metal_free = 1 - metal_mass_fraction
    H_total = fh * metal_free
    He_total = (1 - fh) * metal_free
    # someday, maybe we'll include D in the total
    D_total = H_total * d2h

    fc_density = initial_density / my_chemistry.density_units
    tiny_density = tiny_number * fc_density

    state_vals = {
        "density": fc_density,
        "metal_density": metal_mass_fraction * fc_density,
        "dust_density": dust_to_gas_ratio * fc_density
    }

    # if state == "neutral":
    state_vals["HI_density"] = H_total * fc_density
    state_vals["HeI_density"] = He_total * fc_density
    state_vals["DI_density"] = D_total * fc_density

    state_vals["HII_density"] = initial_xe * fc_density  #debug ?
    state_vals["HeIII_density"] = tiny_density  
    state_vals["e_density"] = state_vals["HII_density"] + state_vals["HeIII_density"] / 2
    state_vals["H2I_density"] = initial_fH2 * fc_density

    for field in fc.density_fields:
        fc[field][:] = state_vals.get(field, tiny_density)

    fc.calculate_mean_molecular_weight()
    fc["internal_energy"] = temperature / \
        fc.chemistry_data.temperature_units / \
        fc["mean_molecular_weight"] / (my_chemistry.Gamma - 1.0)
    fc["x_velocity"][:] = 0.0
    fc["y_velocity"][:] = 0.0
    fc["z_velocity"][:] = 0.0


    #evolve the gas from initial redshift to final redshift
    current_redshift = initial_redshift
    current_time = cosmo.age(current_redshift)*1e3 # convert from Gyr to Myr
    data = defaultdict(list)
    while current_redshift > final_redshift:
        print(f"Redshift: {current_redshift}, Time: {current_time:.2f} Myr")
        dz = -0.01 * current_redshift  # step size
        Hz = cosmo.Hz(current_redshift)/3.086e19  #convert km/s/Mpc to s^(-1)
        dt_dz = -1/(1+current_redshift)/Hz
        dtMyr_dz = dt_dz / my_chemistry.time_units  # convert to Myr
        dtMyr = dtMyr_dz * dz

        add_to_data(fc, data, extra={"time": current_time})
        new_nH, new_temperature = get_nH_T_in_halo(current_redshift, z_vir, T_vir)
        new_density = new_nH * mass_hydrogen_cgs
        density_ratio = new_density / (fc["density"][0] * my_chemistry.density_units)
        # update densities
        for field in fc.density_fields:
            fc[field] *= density_ratio

        fc.calculate_mean_molecular_weight()
        fc["internal_energy"] = temperature / \
        fc.chemistry_data.temperature_units / \
        fc["mean_molecular_weight"] / (my_chemistry.Gamma - 1.0)

        fc.solve_chemistry(dtMyr)

        current_redshift += dz
        current_time += dtMyr
        
    for field in data:
        data[field] = np.squeeze(np.array(data[field]))
        


    # print("k1:", my_chemistry.k1)
    # print("shape of k1:", my_chemistry.k1.shape)
    # print("k28:",my_chemistry.k28)
    # let the gas cool at constant density from the starting temperature
    # down to a lower temperature to get the species fractions in a
    # reasonable state.
    # data0 = evolve_constant_density(
    #     fc, final_temperature=cooling_temperature,
    #     safety_factor=0.1)
    #debug: different H2 fractions
    # fc["H2I_density"][:] = fc["density"][:]*1.0e-6
    # print(data0['time'].in_units('Myr'))  
    # print(data0["H2I_density"] / data0["density"])

    # if my_chemistry.use_volumetric_heating_rate:
    #     fc["volumetric_heating_rate"][:] = volumetric_heating_rate

    return data


def test_cloudy_data():
    filename = '/home/zwu/grackle/input/cloudy_metals_2008_3D.h5'



if __name__ == "__main__":
    data = run_grackle_cosmic_chemistry(initial_redshift=300, final_redshift=15, z_vir=25, T_vir=np.nan)
    print("Final data keys:", data.keys())
    print(data['time'])
    print(data['time'].shape)
    print(data['e_density']/data['density'])
    print(data['H2I_density']/data['density']) 