import numpy as np
import matplotlib.pyplot as plt
import os
import matplotlib.ticker as ticker
from matplotlib.ticker import LogLocator
from matplotlib.ticker import FixedLocator
from matplotlib.colors import SymLogNorm
import cmcrameri.cm as cmc
from scipy.interpolate import interp1d
from colossus.cosmology import cosmology


from physical_constants import h_Hubble, H0_s, Omega_m, Omega_b, Ombh2, Myr, cosmo, Msun, mu_minihalo, eV, kB
from HaloProperties import Temperature_Virial_analytic, get_gas_lognH_analytic, \
inversefunc_Temperature_Virial_analytic, get_mass_density_analytic
from Grackle_cooling import run_constdensity_model
from Analytic_Model import integrate_SHMF_heating_for_single_host
from HaloMassFunction import T_CMB
from utilities import integrate_ode_z

#Before loading xe_evolution.dat, make sure it has been generated by recombination_camb.py
xe_data_CAMB = np.loadtxt('xe_evolution.dat', skiprows=1)  # Skip first row
z_CAMB = xe_data_CAMB[:, 0]  # First column (redshift)
xe_CAMB = xe_data_CAMB[:, 1]  # Second column (free electron fraction)
xe_interp_func = interp1d(z_CAMB, xe_CAMB, bounds_error=False, fill_value='extrapolate')

#Before loading Tgas_evolution.dat, make sure it has been generated by Tgas_evolution_Compton()
Tgas_data = np.loadtxt('Tgas_evolution.dat', skiprows=1)  # Skip first row
z_Tgas = Tgas_data[:, 0]  # First column (redshift)
Tgas = Tgas_data[:, 1]  # Second column (gas temperature)
Tgas_interp_func = interp1d(z_Tgas, Tgas, bounds_error=False, fill_value='extrapolate')


def K_Tegmark97(reaction_index, T, z):
    #Table 1 in Tegmark 1997, return reaction rate in cm^3/s

    T_gamma = T_CMB(z)  
    if reaction_index == 1:
        #more accurate: 6.95, 6.112, 6.116 in Peebles 1993?
        return 1.88e-10 * T**(-0.64)
    elif reaction_index == 2:
        return 1.83e-18 * T**0.88
    elif reaction_index == 3:
        return 1.3e-9
    elif reaction_index == 4:
        return 0.114 * T_gamma**2.13 * np.exp(-8650.0 / T_gamma)
    elif reaction_index == 5:
        return 1.85e-23 * T**1.8
    elif reaction_index == 6:
        return 6.4e-10
    elif reaction_index == 7:
        return 6.36e5 * np.exp(-71600.0 / T_gamma)
    elif reaction_index == 8:
        return 4.91e-22 * T_gamma**4
    else:
        raise ValueError("Invalid reaction index. Must be an integer from 1 to 8.")

def get_km_Tegmark97(T, xe, z):
    #effective formation rate of H2
    nH = get_nH_Tegmark97(z)
    k2 = K_Tegmark97(2, T, z)  
    k3 = K_Tegmark97(3, T, z)
    k4 = K_Tegmark97(4, T, z)
    k5 = K_Tegmark97(5, T, z)
    k6 = K_Tegmark97(6, T, z)
    k7 = K_Tegmark97(7, T, z)

    k2channel_all = k3 + k4/((1-xe)*nH)
    k5channel_all = k6 + k7/((1-xe)*nH)
    km = k2*k3/k2channel_all + k5*k6/k5channel_all
    return km


def get_k1_Peebles97(T):
    T4 = T / 1e4
    k1 = 2.6e-13*T4**(-0.8)
    return k1

def test_k1():
    T_list = np.logspace(2, 4, 50)  # Temperature in K
    z = 15
    k1_Tegmark = np.array([K_Tegmark97(1, T, z) for T in T_list])
    k1_Peebles = np.array([get_k1_Peebles97(T) for T in T_list])

    fig, ax = plt.subplots(figsize=(8, 6))
    ax.plot(T_list, k1_Tegmark, label='Tegmark 1997', color='blue')
    ax.plot(T_list, k1_Peebles, label='Peebles 1993', color='red')
    ax.set_xscale('log')
    ax.set_yscale('log')
    ax.legend()
    ax.grid()
    ax.set_xlabel('Temperature [K]', fontsize=14)
    ax.set_ylabel('k1 [cm^3/s]', fontsize=14)
    
    plt.savefig("Analytic_results/Yoshida03/k1_reaction_rate_comparison.png", dpi=300)


def lgM_to_Tvir_minihalo(lgM, z):
    #lgM in Msun/h
    Tvir = Temperature_Virial_analytic(10**lgM/h_Hubble, z, mean_molecular_weight=mu_minihalo) #Tvir in K
    return Tvir

def Tvir_to_lgM_minihalo(Tvir, z):
    Mvir = inversefunc_Temperature_Virial_analytic(Tvir, z, mean_molecular_weight=mu_minihalo) #Mvir in Msun
    lgM = np.log10(Mvir * h_Hubble)  # convert to lgM [M_sun/h]
    return lgM

def get_Hubble_timescale_Tegmark97(z):
    #return Hubble timescale in Myr, modify z to 1+z for accuracy at low z
    #Tegmark 1997 Eq. 10

    return 6.5/h_Hubble * ((1+z)/100)**(-1.5)


def get_nH_Tegmark97(z):
    #Tegmark 1997 Eq. 1, modify z to 1+z for accuracy at low z
    #nH in cm^-3
    return 23*((1+z)/100)**3*h_Hubble**2*Omega_b/0.015

def get_fH2_Tegmark97(T, z=None):
    #H2 mass fraction for Tvir
    #Tegmark 1997 Eq.17
    #T in K, return fH2
    if z is None:
        high_order_term = 0.0
    else:
        n = get_nH_Tegmark97(z)
        high_order_term = 7.4e8/n*(1+z)**2.13*np.exp(-3173/(1+z))
        # print("high_order_term = ", high_order_term)
    
    return 3.5e-4 * (T/1e3)**1.52*(1+high_order_term)**(-1)

def get_critical_fH2_Tegmark97(T, z):
    #where cooling time = Hubble time(z), modify z to 1+z for accuracy at low z
    #Eq.11 Tegmark 1997
    T3 = T/1e3
    fc = 0.00016/(h_Hubble*Omega_b/0.03) * ((1+z)/100)**(-1.5) / (1+10*T3**3.5/(60+T3**4)) *np.exp(512/T)
    return fc
    
def get_Tvir_Tegmark97(M, z):
    #M in Msun, Tegmark Eq. 28
    return 485*h_Hubble**(2/3) * (M/1e4)**(2/3) * (1+z)/100


def get_Tvir_Yoshida03(M, z, mean_molecular_weight):
    #M in Msun
    Delta = 200
    T =  1.98e4*(mean_molecular_weight/0.6)*(M*h_Hubble/1e8)**(2/3) \
        *(Omega_m*Delta/18/np.pi**2)**(1/3)*(1+z)/10
    return T

def get_fH2_Yoshida03(T):
    
    T3 = T/1e3
    fH2 = 4.7e-5 * T3**1.52
    return fH2

def test_Tvir():
    #compare Tvir from Yoshida03, Tegmark97 and our model
    z = 15
    M_list = np.logspace(4, 8, 50)
    Tvir_Yoshida = np.array([get_Tvir_Yoshida03(M, z, 1.0) for M in M_list])
    Tvir_Tegmark = np.array([get_Tvir_Tegmark97(M, z) for M in M_list])
    Tvir_analytic = np.array([Temperature_Virial_analytic(M, z, mean_molecular_weight=mu_minihalo) for M in M_list])
    fig = plt.figure(figsize=(8, 6))
    ax = fig.add_subplot(111)
    ax.plot(M_list, Tvir_Yoshida, label='Yoshida 2003', color='blue')
    ax.plot(M_list, Tvir_Tegmark, label='Tegmark 1997', color='red')
    ax.plot(M_list, Tvir_analytic, label='our model, mu = 1.0', color='green')
    ax.set_xscale('log')
    ax.set_yscale('log')
    ax.legend()
    ax.grid()
    ax.set_xlabel('M [Msun]', fontsize=14)
    ax.set_ylabel('Tvir [K]', fontsize=14)
    ax.set_title(f'z = {z}', fontsize=14)
    plt.tight_layout()
    filename = os.path.join("Analytic_results/Yoshida03", "compare_Tvir.png")
    plt.savefig(filename, dpi=300)



def compare_Hubble_timescale_and_nH():
    z_list = np.linspace(0, 30, 100)
    t_Hubble_Tegmark = get_Hubble_timescale_Tegmark97(z_list)
    t_Hubble_colossus = np.array([cosmo.age(z)*1e3 for z in z_list])
    # print("t_Hubble_Tegmark = ", t_Hubble_Tegmark)
    # print("t_Hubble_colossus = ", t_Hubble_colossus)
    fig = plt.figure(figsize=(8, 6))
    ax = fig.add_subplot(111)
    ax.plot(z_list, t_Hubble_Tegmark, label='Tegmark 1997', color='blue')
    ax.plot(z_list, t_Hubble_colossus, label='Colossus', color='red')
    ax.set_yscale('log')
    ax.legend()
    ax.grid()
    ax.set_xlabel('z', fontsize=14)
    ax.set_ylabel('Hubble time [Myr]', fontsize=14)
    ax.set_title('Hubble time vs redshift', fontsize=16)
    plt.tight_layout()
    filename = os.path.join("Analytic_results/Yoshida03", "Hubble_time_vs_z.png")
    if not os.path.exists("Analytic_results/Yoshida03"):
        os.makedirs("Analytic_results/Yoshida03")
    plt.savefig(filename, dpi=300)

    #also compare nH in Tegmark 1997 and our model
    nH_Tegmark = get_nH_Tegmark97(z_list)
    lognH_analytic = get_gas_lognH_analytic(z_list)
    nH_Peebles = np.array([1.12e-5*Ombh2*(1+z)**3 for z in z_list])  # Peebles 1993 Eq. 1
    nH200_Peebles = np.array([1.12e-5*Ombh2*(1+z)**3*200 for z in z_list])  # Peebles 1993 Eq. 1, 200 times critical density
    nH_analytic = 10**lognH_analytic
    fig = plt.figure(figsize=(8, 6))
    ax = fig.add_subplot(111)
    ax.plot(z_list, nH_Tegmark, label='Tegmark 1997', color='blue')
    ax.plot(z_list, nH_analytic, label='our model', color='red')
    ax.plot(z_list, nH_Peebles, label='Peebles', color='green')
    ax.plot(z_list, nH200_Peebles, label='Peebles x200', color='green', linestyle='--')
    ax.set_yscale('log')
    ax.legend()
    ax.grid()
    ax.set_xlabel('z', fontsize=14)
    ax.set_ylabel('nH [cm^-3]', fontsize=14)
    ax.set_title('nH vs redshift', fontsize=16)
    plt.tight_layout()
    filename = os.path.join("Analytic_results/Yoshida03", "nH_vs_z.png")
    plt.savefig(filename, dpi=300)


def test_fH2_Tegmark():
    z_list = np.array([100, 50, 25])
    nH_Tegmark = get_nH_Tegmark97(z_list)
    print("nH_Tegmark = ", nH_Tegmark)
    T_list = np.logspace(2, 4, 50)
    All_critical_fH2 = []
    All_H2_formation = []
    for z in z_list:
        fH2_critical = np.array([get_critical_fH2_Tegmark97(T, z) for T in T_list])
        fH2_formation = np.array([get_fH2_Tegmark97(T, z) for T in T_list])
        All_critical_fH2.append(fH2_critical)
        All_H2_formation.append(fH2_formation)
    All_critical_fH2 = np.array(All_critical_fH2)
    All_H2_formation = np.array(All_H2_formation)

    fig = plt.figure(figsize=(8, 6))
    linestyles = ['-',':','--']
    for i, z in enumerate(z_list):
        plt.plot(T_list, All_critical_fH2[i], label='critical fraction, z='+str(z), linestyle=linestyles[i], color='k')
        plt.plot(T_list, All_H2_formation[i], label='H2 produced, z='+str(z), linestyle=linestyles[i], color='red')
    plt.xscale('log')
    plt.yscale('log')
    plt.xlabel('T [K]')
    plt.ylabel('fH2')
    plt.title('Tegmark 1997 model')
    plt.legend()
    plt.tight_layout()
    filename = os.path.join("Analytic_results/Yoshida03", "Tegmark_fH2_vs_T_z.png")
    plt.savefig(filename, dpi=300)

def test_fH2():
    z = 20
    M = 1.0e6/h_Hubble #Msun
    T1 = get_Tvir_Yoshida03(M, z, 1.0)
    T2 = Temperature_Virial_analytic(M, z, 1.0)
    print("T_vir_Yoshida03 = ", T1)
    print("T_vir_analytic = ", T2)
    print("T_vir_Yoshida03 / T_vir_analytic = ", T1/T2)

    M_test = 5.0e5/h_Hubble #Msun
    T_test = get_Tvir_Yoshida03(M_test, z, 1.0)

    fH2_test = get_fH2_Yoshida03(T_test)
    print("fH2_test = ", fH2_test)
    fH2_test_Tegmark = get_fH2_Tegmark97(T_test)
    print("fH2_test_Tegmark = ", fH2_test_Tegmark)
    print("fH2_test / fH2_test_Tegmark = ", fH2_test/fH2_test_Tegmark)

def x_t_Tegmark97(x0, t, n, T):
    k1 = K_Tegmark97(1, T, 0)  # k1 doesn't depend on z in this case
    x_t = x0/(1+x0*n*k1*t)
    return x_t

def dxe_dz_Tegmark97(z, xe, T):
    T = Tgas_interp_func(z)  # debug: reset T to Tgas at redshift z
    # T = 5000
    nH = get_nH_Tegmark97(z)/200 #debug/200
    k1 = K_Tegmark97(1, T, z)
    dxe_dt = - k1 * nH * xe**2
    Hz = cosmo.Hz(z)/3.086e19  #convert km/s/Mpc to s^(-1)
    dt_dz = -1/(1+z)/Hz
    dxe_dz = dxe_dt * dt_dz
    return dxe_dz

def dxe_dz_Peebles99(z, xe):
    T = T_CMB(z)
    T4 = T / 1e4
    nH = 1.12e-5 * Ombh2 * (1+z)**3  # Peebles 1993 Eq. 1
    # nH =  get_nH_Tegmark97(z)/200
    # lognH = get_gas_lognH_analytic(z)
    # nH  = 10**lognH/200  
    alpha_e = 2.6e-13* T4**(-0.8) 
    Lambda_2s = 8.23 #s^(-1), the two-photon decay rate from metastable state 2s to ground state
    beta_e_over_Lambda = 8e7*T4**0.7*np.exp(-3.95/T4)
    beta_e = beta_e_over_Lambda * Lambda_2s
    C_approx = 1.0/(1.0+beta_e_over_Lambda)
    h_nualpha = 10.2*eV
    exp_factor = np.exp(-h_nualpha/(T*kB))
    dxe_dt = - C_approx*(alpha_e*xe**2*nH -beta_e*(1-xe)*exp_factor)
    Hz = cosmo.Hz(z)/3.086e19  #convert km/s/Mpc to s^(-1)
    dt_dz = -1/(1+z)/Hz
    dxe_dz = dxe_dt * dt_dz
    return dxe_dz

def dxefH2_dz_Tegmark97(z, y, z_vir, T_vir):
    xe = y[0]
    fH2 = y[1]
    if z >= z_vir:
        T = Tgas_interp_func(z)
        nH = get_nH_Tegmark97(z)/200
        # return np.array([0, 0])  #Another option: do not evolve before virialization (has little effect on final result)      
    else:
        T = T_vir
        nH = get_nH_Tegmark97(z)
    k1 = K_Tegmark97(1, T, z)
    km = get_km_Tegmark97(T, xe, z)
    dxe_dt = - k1 * nH * xe**2
    dfH2_dt = km * nH * (1 - xe - 2*fH2) * xe
    Hz = cosmo.Hz(z)/3.086e19  
    dt_dz = -1/(1+z)/Hz
    dxe_dz = dxe_dt * dt_dz
    dfH2_dz = dfH2_dt * dt_dz
    return np.array([dxe_dz, dfH2_dz])
    

def plot_xe_vs_z():#debug: n and T fixed?

    xe_data_CAMB = np.loadtxt('xe_evolution.dat', skiprows=1)  # Skip first row
    z_CAMB = xe_data_CAMB[:, 0]  # First column (redshift)
    xe_CAMB = xe_data_CAMB[:, 1]  # Second column (free electron fraction)
    #do not start at very high z (z>>300) because Tegmark's xe(z) is not accurate there
    z_start = 300
    xe_interp_func = interp1d(z_CAMB, xe_CAMB, bounds_error=False, fill_value='extrapolate')
    xe_at_z_start = xe_interp_func(z_start)
    fH2_at_z_start = 1.0e-7
    print(f"xe at z = {z_start} is {xe_at_z_start}")
    print(f"fH2 at z = {z_start} is {fH2_at_z_start}")

    z_final = 15

    xe_intPeebles_result = integrate_ode_z(dxe_dz_Peebles99, z_initial=1800, y_initial=1.0, z_final=z_final)
    # print("xe_intPeebles_result = ", xe_intPeebles_result)

    #use Tgas(z) throughout the integration
    xefH2_intTegmark_Tgas = integrate_ode_z(dxefH2_dz_Tegmark97, z_initial=z_start, 
                                            y_initial=np.array([xe_at_z_start, fH2_at_z_start]),
                                            z_final = 15, ode_args=(-1.0 , np.nan))
    
    # print("xefH2_intTegmark_Tgas = ", xefH2_intTegmark_Tgas)


    Tvir_list = [100, 1000, 3000]
    zvir_list = [25, 50, 100]
    


    z_list = np.logspace(np.log10(15), np.log10(z_start), 1000)
    t_list_colossus = np.array([cosmo.age(z) for z in z_list]) * 1e3 * Myr  # Convert to s
    nH_list = np.array([get_nH_Tegmark97(z) for z in z_list])
    print("z_list = ", z_list)
    print("t_list_colossus = ", t_list_colossus)
    print("nH_list = ", nH_list)

    #1. xe(z) analytic result given by Eq. 15 in Tegmark 1997
    # X_t_results_all = []
    # for i in range(len(T_const_nH_combinations)):
    #     T_const = T_const_nH_combinations[i][0]
    #     nH_at_zvir = T_const_nH_combinations[i][1]
    #     # Calculate xe at each z using the analytical solution
    #     x0 = xe_at_z_start
    #     n, T = nH_at_zvir, T_const
    #     x_t_results = x_t_Tegmark97(x0, t_list_colossus, n, T)
    #     X_t_results_all.append(x_t_results)
    
    #2. xe(z) from integration of Eq. 12 in Tegmark 1997
    xefH2_intTegmark_allresults = []
    for Tvir in Tvir_list:
        for zvir in zvir_list:
            print("calculating Tvir = ", Tvir, "K, zvir = ", zvir)
            y_initial = np.array([xe_at_z_start, fH2_at_z_start]) #debug: initial fH2 ?
            result = integrate_ode_z(dxefH2_dz_Tegmark97, 
                                                   z_initial=z_start, 
                                                   y_initial=y_initial, 
                                                   z_final=z_final,
                                                   ode_args=(zvir, Tvir))
            # print("result (xe, fH2): ", result['y'])
            xefH2_intTegmark_allresults.append(result)

    # z_list, xe_list = integrate_xe(T_const)
    # ax.plot(z_list, xe_list, label=f'T = {T_const} K', color='blue')

    colors = ['b', 'g', 'r']
    linestyles = ["--", ":", '-']

    #plot xe(z)
    fig, ax = plt.subplots(figsize=(8, 6))
    CAMB_mask = (z_CAMB > 15) & (z_CAMB < 1800)
    ax.plot(z_CAMB[CAMB_mask], xe_CAMB[CAMB_mask], label='CAMB data', color='k', linestyle='-')
    ax.plot(xe_intPeebles_result['z'], xe_intPeebles_result['y'][0], label='Peebles 1999', color='orange', linestyle='--')
    ax.plot(xefH2_intTegmark_Tgas['z'], xefH2_intTegmark_Tgas['y'][0], label='Tegmark+Tgas model', color='purple', linestyle='-.')
    for i in range(len(Tvir_list)):
        for j in range(len(zvir_list)):
            result = xefH2_intTegmark_allresults[i*len(zvir_list) + j]
            z = result['z']
            xe = result['y'][0]
            label = f'Tegmark+ Tvir={Tvir_list[i]} K, zvir={zvir_list[j]}'
            ax.plot(z, xe, label=label, color=colors[i], linestyle=linestyles[j])
            
    ax.invert_xaxis()
    ax.set_xscale('log')
    ax.set_yscale('log')
    ax.set_xlabel('Redshift (z)', fontsize=14)
    ax.set_ylabel('Ionization Fraction (xe)', fontsize=14)
    ax.grid()
    ax.legend()
    plt.tight_layout()
    filename = os.path.join("Analytic_results/Yoshida03", f"xe_vs_z.png")
    plt.savefig(filename, dpi=300)

    #also plot fH2(z)
    fig, ax = plt.subplots(figsize=(8, 6))
    ax.plot(xefH2_intTegmark_Tgas['z'], xefH2_intTegmark_Tgas['y'][1], label='Tegmark+Tgas model', color='purple', linestyle='-.')
    for i in range(len(Tvir_list)):
        for j in range(len(zvir_list)):
            result = xefH2_intTegmark_allresults[i*len(zvir_list) + j]
            z = result['z']
            fH2 = result['y'][1]
            label = f'Tegmark+ Tvir={Tvir_list[i]} K, zvir={zvir_list[j]}'
            ax.plot(z, fH2, label=label, color=colors[i], linestyle=linestyles[j])
    ax.invert_xaxis()
    ax.set_xscale('log')
    ax.set_yscale('log')
    ax.set_xlabel('Redshift (z)', fontsize=14)
    ax.set_ylabel('H2 Fraction (fH2)', fontsize=14)
    ax.grid()
    ax.legend()
    plt.tight_layout()
    filename = os.path.join("Analytic_results/Yoshida03", f"fH2_vs_z.png")
    plt.savefig(filename, dpi=300)

    #now use a full list of Tvir
    print("Using a full list of Tvir for different zvir ...")
    zvir_list = [25, 50, 100]
    Tvir_fulllist = np.logspace(np.log10(100), np.log10(5000), 20)  
    finalfH2_intTegmark_allresults = []
    for zvir in zvir_list:
        finalfH2_for_zvir = np.zeros(len(Tvir_fulllist))
        for j, Tvir in enumerate(Tvir_fulllist):
            print("calculating Tvir = ", Tvir, "K, zvir = ", zvir)
            y_initial = np.array([xe_at_z_start, fH2_at_z_start])
            result = integrate_ode_z(dxefH2_dz_Tegmark97,z_initial=z_start,y_initial=y_initial,
                                                   z_final=z_final,ode_args=(zvir, Tvir))
            finalfH2 = result['y'][1][-1]  # Get the final fH2 value
            finalfH2_for_zvir[j] = finalfH2
        finalfH2_intTegmark_allresults.append(finalfH2_for_zvir)
    finalfH2_intTegmark_allresults = np.array(finalfH2_intTegmark_allresults)

    #plot final fH2 vs Tvir for different zvir
    fig, ax = plt.subplots(figsize=(8, 6))
    linestyles = ["--", ":", '-']

    for i, zvir in enumerate(zvir_list):
        ax.plot(Tvir_fulllist, finalfH2_intTegmark_allresults[i], 
                label=f'zvir={zvir}', color='k', linestyle=linestyles[i])
    ax.set_xscale('log')
    ax.set_yscale('log')
    ax.set_xlabel('Tvir [K]', fontsize=14)
    ax.set_ylabel('fH2 at z = 15', fontsize=14)
    ax.set_ylim(1e-6, 2e-2)
    ax.grid()
    ax.legend()
    plt.tight_layout()
    filename = os.path.join("Analytic_results/Yoshida03", f"final_fH2_vs_Tvir.png")
    plt.savefig(filename, dpi=300)





def plot_fH2_vs_T(z):

    #debug: compare halo mass-Tvir in John Wise paper
    # M_in_Msun_test = inversefunc_Temperature_Virial_analytic(7000, z, mean_molecular_weight=1.0) #Mvir in Msun
    # print("M_in_Msun_test = ", M_in_Msun_test)
    # Tvir_test = Temperature_Virial_analytic(6e6, 15, mean_molecular_weight=1.23)
    # print("Tvir_test = ", Tvir_test)

    output_dir = "/home/zwu/21cm_project/unified_model/Analytic_results/Yoshida03"

    #test different Hubble timescale
    t_Hubble_Tegmark = get_Hubble_timescale_Tegmark97(z)
    t_Hubble_colossus = cosmo.age(z)*1e3
    print(f"t_Hubble_Tegmark = {t_Hubble_Tegmark} Myr")
    print(f"t_Hubble_colossus = {t_Hubble_colossus} Myr")
    # t_Hubble_Myr = get_Hubble_timescale_Tegmark97(z)
    t_Hubble_Myr = t_Hubble_colossus
    # t_Hubble_Myr = 1.0/H0_s/Myr

    lognH = get_gas_lognH_analytic(z)
    # lognH = np.log10(500)
    print("lognH = ", lognH)
    nH = 10**lognH
    print("nH = ", nH)


    #plot fH2 vs T
    T_list = np.logspace(2, np.log10(1.1e4), 50)
    initial_fH2_list = np.logspace(-6, -1, 50)
    cooling_rate_for_initial_fH2 = np.zeros(len(initial_fH2_list))
    cooling_timescale_for_initial_fH2 = np.zeros(len(initial_fH2_list))
    cooling_timescale_all = np.zeros((len(T_list), len(initial_fH2_list)))
    cooling_rate_all = np.zeros((len(T_list), len(initial_fH2_list)))
    final_fH2_all = np.zeros((len(T_list), len(initial_fH2_list)))
    # for j, fH2 in enumerate(initial_fH2_list):

    #     cooling_data = run_constdensity_model(
    #     False, z, lognH, 0.0, 0.0, 
    #     T_list, 0.0, f_H2=fH2, UVB_flag=False, 
    #     Compton_Xray_flag=False, dynamic_final_flag=False)
    #     cooling_time = cooling_data['cooling_time']
    #     # print("cooling_time = ", cooling_time.in_units('Myr'))
    #     cooling_timescale_all[:, j] = cooling_time.in_units('Myr')
    #     # print("cooling_timescale_all = ", cooling_timescale_all[:,j])
    #     cooling_rate_all[:, j] = cooling_data['cooling_rate']

    #first loop over T_list, then initial_fH2_list for debugging
    for i in range(len(T_list)):
        Tvir = T_list[i]
        print("Tvir = ", Tvir)
        for j in range(len(initial_fH2_list)):
            fH2 = initial_fH2_list[j]
            cooling_data = run_constdensity_model(
                False, z, lognH, 0.0, 0.0, 
                Tvir, 0.0, f_H2=fH2, UVB_flag=False, 
                Compton_Xray_flag=False, dynamic_final_flag=False)
            cooling_time = cooling_data['cooling_time']
            cooling_timescale_for_initial_fH2[j] = cooling_time.in_units('Myr')[0].v
            cooling_rate_for_initial_fH2[j] = cooling_data['cooling_rate'][0].v
            final_fH2_all[i, j] = cooling_data['H2I_density'][0].v/cooling_data['density'][0].v

        print("final_fH2 = ", final_fH2_all[i, :])
        print("cooling_timescale_for_initial_fH2 = ", cooling_timescale_for_initial_fH2)

        #interpolate cooling rate and cooling timescale as a function of final fH2
        sorted_indices = np.argsort(final_fH2_all[i, :])
        sorted_final_fH2 = final_fH2_all[i, :][sorted_indices]
        sorted_cooling_timescales = cooling_timescale_for_initial_fH2[sorted_indices]
        sorted_cooling_rates = cooling_rate_for_initial_fH2[sorted_indices]
        valid_mask = (
            (sorted_cooling_timescales < 0) &
            (sorted_cooling_rates < 0)
        )
        x = np.log10(sorted_final_fH2[valid_mask])
        y_timescale = np.log10(np.abs(sorted_cooling_timescales[valid_mask]))
        y_rate = np.log10(np.abs(sorted_cooling_rates[valid_mask]))
        interp_timescale_log = interp1d(x, y_timescale, bounds_error=False, fill_value=np.nan)
        interp_rate_log = interp1d(x, y_rate, bounds_error=False, fill_value=np.nan)

        log_fH2_targets = np.log10(np.array(initial_fH2_list))
        interpolated_timescale = 10 ** interp_timescale_log(log_fH2_targets)
        interpolated_rate = 10 ** interp_rate_log(log_fH2_targets)
        cooling_timescale_all[i, :] = -interpolated_timescale
        print("interpolated_timescale = ", -interpolated_timescale)
        cooling_rate_all[i, :] = -interpolated_rate
        print("interpolated_rate = ", -interpolated_rate)


    



            


    # print("cooling_timescale_all = ", cooling_timescale_all)
    # print("cooling_rate_all = ", cooling_rate_all)
    # print("energy in the unit cell = ",cooling_timescale_all*cooling_rate_all) 

    #include DF heating
    print("Calculating DF heating...")
    DF_heating_list = np.zeros(len(T_list))
    normalized_heating_list = np.zeros(len(T_list))
    for i in range(len(T_list)):
        Tvir = T_list[i]
        M_in_Msun = inversefunc_Temperature_Virial_analytic(Tvir, z, mean_molecular_weight=mu_minihalo) #Mvir in Msun
        Mvir = M_in_Msun * h_Hubble #Msun/h
        lgM = np.log10(Mvir)
        DF_heating = integrate_SHMF_heating_for_single_host(z, -3, 0, lgM, "BestFit_z")
        DF_heating_erg = DF_heating * 1.0e7 # erg/s
        halo_density = get_mass_density_analytic(z)
        halo_volume = M_in_Msun * Msun / halo_density
        halo_volume_cm3 = halo_volume * 1.0e6 # cm^3
        DF_heating_density = DF_heating_erg / halo_volume_cm3 # erg/s/cm^3
        normalized_heating = DF_heating_density/nH**2 # erg/s*cm^3

        DF_heating_list[i] = DF_heating_density
        normalized_heating_list[i] = normalized_heating
    
    cooling_rate_with_DF_all = np.full((len(T_list), len(initial_fH2_list)), np.nan)
    cooling_timescale_with_DF_all = np.full((len(T_list), len(initial_fH2_list)), np.nan)

    for i in range(len(T_list)):
        for j in range(len(initial_fH2_list)):
            cooling_rate = cooling_rate_all[i, j]
            cooling_timescale = cooling_timescale_all[i, j]
            
            if not np.isnan(cooling_rate) and not np.isnan(cooling_timescale):
                energy_density_in_cell = cooling_rate * cooling_timescale
                #debug factor * DF heating
                cooling_rate_with_DF = cooling_rate + normalized_heating_list[i]
                cooling_rate_with_DF_all[i, j] = cooling_rate_with_DF

                if cooling_rate_with_DF != 0:
                    cooling_timescale_with_DF = energy_density_in_cell / cooling_rate_with_DF
                    cooling_timescale_with_DF_all[i, j] = cooling_timescale_with_DF
    
    #find where cooling_rate_with_DF crosses zero
    fH2_zero_netcooling = np.full(len(T_list), np.nan)  # Store fH2 values where cooling rate crosses zero
    for i in range(len(T_list)):
        for j in range(len(initial_fH2_list) - 1, 0, -1):
            ct1 = cooling_rate_with_DF_all[i, j]
            ct2 = cooling_rate_with_DF_all[i, j - 1]
            if (not np.isnan(ct1)) and (not np.isnan(ct2)):
                if ct1 < 0.0 and ct2 > 0.0:
                    # Interpolate to find the fH2 where cooling rate crosses zero
                    fH2_zero_netcooling[i] = initial_fH2_list[j]
                    break
            if np.all(np.isnan(cooling_rate_with_DF_all[i, :])): #all nan, near 1e4K
                fH2_zero_netcooling[i] = initial_fH2_list[0]
            elif np.nanmax(cooling_rate_with_DF_all[i, :]) < 0.0: #all negative (net cooling)
                fH2_zero_netcooling[i] = initial_fH2_list[0]
            elif np.nanmin(cooling_rate_with_DF_all[i, :]) > 0.0: #all positive (net heating)
                fH2_zero_netcooling[i] = initial_fH2_list[-1]


    #find the critical fH2 for each T
    def find_critical_fH2(timescale_array, initial_fH2_list, T_list, t_Hubble_Myr):
        fH2_critical = np.ones(len(T_list))
        
        for i in range(len(T_list)):
            found = False
            for j in range(len(initial_fH2_list) - 1, 0, -1):
                ct1 = timescale_array[i, j]
                ct2 = timescale_array[i, j - 1]
                if (not np.isnan(ct1)) and (not np.isnan(ct2)):
                    if ct1 < 0.0 and ct2 < 0.0:
                        if -ct1 <= t_Hubble_Myr and -ct2 > t_Hubble_Myr:
                            fH2_critical[i] = initial_fH2_list[j]
                            found = True
                            break
                    elif ct1 <0.0 and ct2 > 0.0 and -ct1 <= t_Hubble_Myr:
                        fH2_critical[i] = initial_fH2_list[j]
                        found = True
                        break
            if not found:
                if np.all(np.isnan(timescale_array[i, :])): #all nan, near 1e4K
                    fH2_critical[i] = initial_fH2_list[0]
                elif 0 < np.nanmax(-timescale_array[i, :]) < t_Hubble_Myr:
                    fH2_critical[i] = initial_fH2_list[0]
                elif np.nanmin(-timescale_array[i, :]) > t_Hubble_Myr or np.nanmax(timescale_array[i, :])> 0.0: #max cooling not enough or all net heating
                    fH2_critical[i] = initial_fH2_list[-1]
                    
        return fH2_critical

    fH2_critical = find_critical_fH2(cooling_timescale_all, initial_fH2_list, T_list, t_Hubble_Myr)
    fH2_with_DF_critical = find_critical_fH2(cooling_timescale_with_DF_all, initial_fH2_list, T_list, t_Hubble_Myr)

    fH2_Tegmark = np.array([get_fH2_Tegmark97(T, z) for T in T_list])
    fH2_Yoshida = get_fH2_Yoshida03(T_list)
    fH2_critical_Tegmark = np.array([get_critical_fH2_Tegmark97(T, z) for T in T_list])
    line_styles = {
    'tegmark_crit': {'color': 'black', 'linestyle': '-', 'linewidth': 2.5, 
                'label': 'Critical line (Tegmark97)'},
    'grackle_crit': {'color': 'darkgreen', 'linestyle': '-', 'linewidth': 2, 
                'label': 'Critical line (Grackle)'},
    'grackle_df_crit': {'color': 'darkorange', 'linestyle': '-', 'linewidth': 2, 
                   'label': 'Critical line with DF heating (Grackle)'},
    'yoshida_H2produced': {'color': 'dimgray', 'linestyle': '--', 'linewidth': 2, 
                'label': r'H$_2$ produced $\propto$ T$^{1.52}$'},
    'zero_netcooling': {'color': 'magenta', 'linestyle': ':', 'linewidth': 2,
                'label': 'cooling = DF heating'},
    }

    print("cooling with DF = ", cooling_rate_with_DF_all)
    print("max cooling with DF = ", np.nanmax(cooling_rate_with_DF_all))
    print("min cooling with DF = ", np.nanmin(cooling_rate_with_DF_all))
    print("min(abs(cooling rate with DF)) = ", np.nanmin(np.abs(cooling_rate_with_DF_all)))


    print("cooling timescale with DF = ", cooling_timescale_with_DF_all)
    print("max cooling timescale with DF = ", np.nanmax(cooling_timescale_with_DF_all))
    print("min cooling timescale with DF = ", np.nanmin(cooling_timescale_with_DF_all))
    print("min(abs(cooling timescale with DF)) = ", np.nanmin(np.abs(cooling_timescale_with_DF_all)))
    # exit()

    def add_mass_axis_on_top(ax1, T_list, z, Tvir_to_lgM, lgM_to_Tvir):
        """
        add a mass axis on top of the temperature axis in ax1
        Parameters:
        - ax1: matplotlib Axes object with temperature axis
        - T_list: Tvir list [K]
        - z: redshift
        - Tvir_to_lgM: function, Tvir -> log10(M)
        - lgM_to_Tvir: function, log10(M) -> Tvir
        returns:
        - ax2: new Axes object with mass axis
        """
        ax2 = ax1.twiny()
        ax2.set_xlim(ax1.get_xlim())
        ax2.set_xscale('log')

        lgM_min = Tvir_to_lgM(min(T_list), z)
        lgM_max = Tvir_to_lgM(max(T_list), z)
        desired_log_masses = np.arange(int(np.floor(lgM_min)), int(np.ceil(lgM_max)) + 1)

        T_ticks_top = [lgM_to_Tvir(lgM, z) for lgM in desired_log_masses]
        valid_data = [(Tvir, 10**lgM, lgM) for Tvir, lgM in zip(T_ticks_top, desired_log_masses)
                    if min(T_list) <= Tvir <= max(T_list)]

        if valid_data:
            T_ticks_top, M_ticks, log_masses = zip(*valid_data)
            # Set major ticks on top axis
            ax2.set_xticks(T_ticks_top)
            mass_labels = [f"$10^{{{int(lgM)}}}$" for lgM in log_masses]
            ax2.set_xticklabels(mass_labels)
            ax2.xaxis.set_major_locator(FixedLocator(T_ticks_top))
            
            # Generate minor ticks for mass axis
            minor_tick_temps = []
            if log_masses:
                first_lgM = log_masses[0]
                prev_lgM = first_lgM - 1  # Previous decade
                for multiplier in [2, 3, 4, 5, 6, 7, 8, 9]:
                    minor_mass_lgM = prev_lgM + np.log10(multiplier)
                    minor_temp = lgM_to_Tvir_minihalo(minor_mass_lgM, z)
                    if min(T_list) <= minor_temp <= max(T_list):
                        minor_tick_temps.append(minor_temp)
            for i in range(len(log_masses)):
                current_lgM = log_masses[i]
                for multiplier in [2, 3, 4, 5, 6, 7, 8, 9]:
                    minor_mass_lgM = current_lgM + np.log10(multiplier)
                    minor_temp = lgM_to_Tvir_minihalo(minor_mass_lgM, z)
                    if min(T_list) <= minor_temp <= max(T_list):
                        minor_tick_temps.append(minor_temp)
            
            # Set minor ticks
            ax2.xaxis.set_minor_locator(FixedLocator(minor_tick_temps))
            ax2.set_xlabel(r'Halo Mass [M$_\odot$/h]', fontsize=15)
            ax2.tick_params(labelsize=12)
            ax2.tick_params(axis='x', which='minor', labelbottom=False, labeltop=False)

        return ax2


    T_grid, fH2_grid = np.meshgrid(T_list, initial_fH2_list, indexing='ij')

    #1. 2D color plot for cooling rate
    masked_lg_cooling_rate = np.ma.masked_invalid(np.log10(-cooling_rate_all))
    fig, ax1 = plt.subplots(figsize=(9, 7)) 
    cmap = plt.colormaps['seismic_r'].copy()
    cmap.set_bad(color='lightgray') 
    c = plt.pcolormesh(
    T_grid, fH2_grid, masked_lg_cooling_rate, 
    cmap=cmap, shading='auto',
    vmin=np.nanmin(masked_lg_cooling_rate), vmax=np.nanmax(masked_lg_cooling_rate)
    )
    cb = plt.colorbar(c, label=r'log$_{10}$(cooling rate [erg cm$^3$ /s])')  # Add units if known
    mask_1e4 = (T_list <= 1e4)
    ax1.plot(T_list[mask_1e4], fH2_critical_Tegmark[mask_1e4], **line_styles['tegmark_crit'])
    ax1.plot(T_list, fH2_critical, **line_styles['grackle_crit'])
    ax1.plot(T_list, fH2_with_DF_critical, **line_styles['grackle_df_crit'])
    ax1.plot(T_list[mask_1e4], fH2_Yoshida[mask_1e4], **line_styles['yoshida_H2produced'])
    ax1.plot(T_list, fH2_zero_netcooling, **line_styles['zero_netcooling'])
    ax1.set_ylim(1e-6, 1e-1)
    ax1.set_xscale('log')
    ax1.set_yscale('log')
    ax1.set_xlabel('Temperature [K]', fontsize=15)
    ax1.set_ylabel('Molecular Hydrogen Fraction $f_{H_2}$', fontsize=15)
    legend = ax1.legend(fontsize=11, framealpha=0.5)
    ax2 = add_mass_axis_on_top(ax1, T_list, z, Tvir_to_lgM_minihalo, lgM_to_Tvir_minihalo)
    plt.title('Cooling Rate vs Temperature and $f_{H_2}$')
    plt.tight_layout()
    plt.savefig(os.path.join(output_dir, f"cooling_rate_vs_T_fH2_z{z}.png"), dpi=300)
    

    #2. plot the cooling rate with DF heating
    linthresh = 1e-30  # use linear scale between -linthresh and linthresh, otherwise log scale
    net_cooling_with_DF_all = - cooling_rate_with_DF_all
    vmax = np.nanmax(np.abs(net_cooling_with_DF_all))
    vmin = -vmax
    masked_cooling_rate = np.ma.masked_invalid(net_cooling_with_DF_all)

    fig, ax1 = plt.subplots(figsize=(9, 7))
    cmap = plt.colormaps['seismic_r'].copy()
    cmap.set_bad(color='lightgray')

    c = plt.pcolormesh(
        T_grid, fH2_grid, masked_cooling_rate,
        cmap=cmap, shading='auto',
        norm=SymLogNorm(linthresh=linthresh, vmin=vmin, vmax=vmax)
    )
    cb = plt.colorbar(c, label=r'Net Cooling Rate [erg cm$^3$/s]')
    mask_1e4 = (T_list <= 1e4)
    ax1.plot(T_list[mask_1e4], fH2_critical_Tegmark[mask_1e4], **line_styles['tegmark_crit'])
    ax1.plot(T_list, fH2_critical, **line_styles['grackle_crit'])
    ax1.plot(T_list, fH2_with_DF_critical, **line_styles['grackle_df_crit'])
    ax1.plot(T_list[mask_1e4], fH2_Yoshida[mask_1e4], **line_styles['yoshida_H2produced'])
    ax1.plot(T_list, fH2_zero_netcooling, **line_styles['zero_netcooling'])
    ax1.set_ylim(1e-6, 1e-1)
    ax1.set_xscale('log')
    ax1.set_yscale('log')
    ax1.set_xlabel('Temperature [K]', fontsize=15)
    ax1.set_ylabel('Molecular Hydrogen Fraction $f_{H_2}$', fontsize=15)
    legend = ax1.legend(fontsize=11, framealpha=0.5)
    ax2 = add_mass_axis_on_top(ax1, T_list, z, Tvir_to_lgM_minihalo, lgM_to_Tvir_minihalo)
    plt.title('Cooling - DF Heating')
    plt.tight_layout()
    plt.savefig(os.path.join(output_dir, f"cooling_rate_vs_T_fH2_z{z}_withDF.png"), dpi=300)



    #3. 2D color plot for cooling timescale
    masked_lg_cooling_timescale_all = np.ma.masked_invalid(np.log10(-cooling_timescale_all))
    fig, ax1 = plt.subplots(figsize=(9, 7)) 
    cmap = plt.colormaps['seismic'].copy()
    cmap.set_bad(color='lightgray')  
    c = ax1.pcolormesh(
        T_grid, fH2_grid, masked_lg_cooling_timescale_all, 
        cmap=cmap, shading='auto',
        vmin=np.min(masked_lg_cooling_timescale_all), vmax=np.max(masked_lg_cooling_timescale_all)
    )
    cb = plt.colorbar(c, ax=ax1, label=r'log$_{10}$(cooling timescale [Myr])',shrink=1.0, pad=0.02)  
    cb.ax.tick_params(labelsize=14)  

    mask_1e4 = (T_list <= 1e4)
    ax1.plot(T_list[mask_1e4], fH2_critical_Tegmark[mask_1e4], **line_styles['tegmark_crit'])
    ax1.plot(T_list, fH2_critical, **line_styles['grackle_crit'])
    ax1.plot(T_list, fH2_with_DF_critical, **line_styles['grackle_df_crit'])
    ax1.plot(T_list[mask_1e4], fH2_Yoshida[mask_1e4], **line_styles['yoshida_H2produced'])
    ax1.plot(T_list, fH2_zero_netcooling, **line_styles['zero_netcooling'])
    # ax1.plot(T_list[T_list<=1e4], fH2_Tegmark[T_list<=1e4], color='k', linestyle='--', label='H2 fraction produced (Tegmark97)')
    ax1.set_ylim(1e-6, 1e-1)
    ax1.set_xscale('log')
    ax1.set_yscale('log')
    ax1.set_xlabel('Temperature [K]', fontsize=16)
    ax1.set_ylabel(r'Molecular Hydrogen Fraction $f_{\mathrm{H_2}}$', fontsize=16)
    ax1.tick_params(labelsize=12)
    legend = ax1.legend(fontsize=11, framealpha=0.5)
    ax2 = add_mass_axis_on_top(ax1, T_list, z, Tvir_to_lgM_minihalo, lgM_to_Tvir_minihalo)
    title_text = (f'Cooling Timescale vs Temperature and $f_{{\mathrm{{H_2}}}}$ at z = {z}\n'
              f'(Hubble time = {t_Hubble_Myr:.0f} Myr)')
    plt.title(title_text, fontsize=16, pad=20)
    plt.tight_layout()
    plt.savefig(os.path.join(output_dir, f"cooling_timescale_vs_T_fH2_z{z}.png"), dpi=300)
    


    #4. plot the cooling timescale with DF heating
    # linthresh = 1.0
    masked_cooling_timescale_with_DF = np.ma.masked_invalid(-cooling_timescale_with_DF_all)
    display_data = masked_cooling_timescale_with_DF.copy()
    lg_display_data = display_data.copy()
    lg_display_data[display_data > 0] = np.log10(display_data[display_data > 0])
    lg_display_data[display_data <= 0] = -9999  # set negative values to -9999 for display
    lg_display_data = np.ma.masked_where(np.isnan(masked_cooling_timescale_with_DF), lg_display_data)
    cmap = plt.colormaps['seismic'].copy()
    cmap.set_bad(color='lightgray')    # NaNs
    cmap.set_under('black') #for net heating, where cooling timescale doesn't exist
    fig, ax1 = plt.subplots(figsize=(9, 7))
    cmap = plt.colormaps['seismic'].copy()
    cmap.set_bad(color='lightgray')  
    c = ax1.pcolormesh(
        T_grid, fH2_grid, lg_display_data,
        cmap=cmap, shading='auto',
        vmin=0.0  
    )
    cb = plt.colorbar(c, ax=ax1, label=r'log$_{10}$(net cooling timescale [Myr])',shrink=1.0, pad=0.02)  
    cb.ax.tick_params(labelsize=14)  

    mask_1e4 = (T_list <= 1e4)
    ax1.plot(T_list[mask_1e4], fH2_critical_Tegmark[mask_1e4], **line_styles['tegmark_crit'])
    ax1.plot(T_list, fH2_critical, **line_styles['grackle_crit'])
    ax1.plot(T_list, fH2_with_DF_critical, **line_styles['grackle_df_crit'])
    ax1.plot(T_list[mask_1e4], fH2_Yoshida[mask_1e4], **line_styles['yoshida_H2produced'])
    ax1.plot(T_list, fH2_zero_netcooling, **line_styles['zero_netcooling'])
    ax1.set_ylim(1e-6, 1e-1)
    ax1.set_xscale('log')
    ax1.set_yscale('log')
    ax1.set_xlabel('Temperature [K]', fontsize=15)
    ax1.set_ylabel('Molecular Hydrogen Fraction $f_{H_2}$', fontsize=15)
    legend = ax1.legend(fontsize=11, framealpha=0.5)
    ax2 = add_mass_axis_on_top(ax1, T_list, z, Tvir_to_lgM_minihalo, lgM_to_Tvir_minihalo)
    plt.title('Cooling Timescale (with DF) vs Temperature and $f_{H_2}$')
    plt.tight_layout()
    plt.savefig(os.path.join(output_dir, f"cooling_timescale_vs_T_fH2_z{z}_withDF.png"), dpi=300)



  


    #save cooling rate and cooling timescale to txt file
    """
    cooling_rate_filename = os.path.join(output_dir, f"cooling_rate_z{z}.txt")
    cooling_timescale_filename = os.path.join(output_dir, f"cooling_timescale_z{z}.txt")
    
    # Suppose cooling_rate_all has shape (len(T_list), len(initial_fH2_list))
    n_T = len(T_list)
    n_fH2 = len(initial_fH2_list)

    # Create new array with one extra row and column
    cooling_rate_with_labels = np.empty((n_T + 1, n_fH2 + 1))
    cooling_timescale_with_labels = np.empty((n_T + 1, n_fH2 + 1))

    # Fill in headers
    cooling_rate_with_labels[0, 0] = np.nan  # Top-left corner empty or NaN
    cooling_rate_with_labels[0, 1:] = initial_fH2_list  # First row = fH2
    cooling_rate_with_labels[1:, 0] = T_list    # First column = T
    cooling_rate_with_labels[1:, 1:] = cooling_rate_all  # Fill in data

    # Repeat for cooling timescale
    cooling_timescale_with_labels[0, 0] = np.nan
    cooling_timescale_with_labels[0, 1:] = initial_fH2_list
    cooling_timescale_with_labels[1:, 0] = T_list
    cooling_timescale_with_labels[1:, 1:] = cooling_timescale_all

    # Save to file
    np.savetxt(cooling_rate_filename, cooling_rate_with_labels, fmt="%.4e")
    np.savetxt(cooling_timescale_filename, cooling_timescale_with_labels, fmt="%.4e")
    """


if __name__ == "__main__":
    # compare_Hubble_timescale_and_nH()
    # plot_fH2_vs_T(z = 15)
    # test_fH2_Tegmark()
    # test_fH2()
    # test_Tvir()
    # test_k1()
    plot_xe_vs_z()