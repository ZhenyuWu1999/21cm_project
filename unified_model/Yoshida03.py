import numpy as np
import matplotlib.pyplot as plt
import os
import matplotlib.ticker as ticker
from matplotlib.ticker import LogLocator
from matplotlib.ticker import FixedLocator
from matplotlib.colors import SymLogNorm
from matplotlib.cm import ScalarMappable
from matplotlib.colors import Normalize
import cmcrameri.cm as cmc
from scipy.interpolate import interp1d
from colossus.cosmology import cosmology


from physical_constants import h_Hubble, H0_s, Omega_m, Omega_b, Ombh2, Myr, cosmo, Msun, mu_minihalo, \
    eV, kB, Mpc, mp, rho_b0, rho_m0
from HaloProperties import Temperature_Virial_analytic, get_gas_lognH_analytic, \
inversefunc_Temperature_Virial_analytic, get_mass_density_analytic
from Grackle_cooling import run_constdensity_model
from Analytic_Model import integrate_SHMF_heating_for_single_host, \
integrate_SHMF_heating_for_single_host_with_variance, integrate_SHMF_heating_for_single_host_PoissonSampling
from HaloMassFunction import T_CMB
from utilities import integrate_ode_z
from Analytic_halo_profile import gasdensity_core_profile, get_concentration
import Latif_data as latif


#Before loading xe_evolution.dat, make sure it has been generated by recombination_camb.py
xe_data_CAMB = np.loadtxt('xe_evolution.dat', skiprows=1)  # Skip first row
z_CAMB = xe_data_CAMB[:, 0]  # First column (redshift)
xe_CAMB = xe_data_CAMB[:, 1]  # Second column (free electron fraction)
xe_interp_func = interp1d(z_CAMB, xe_CAMB, bounds_error=False, fill_value='extrapolate')

#Before loading Tgas_evolution.dat, make sure it has been generated by Tgas_evolution_Compton()
Tgas_data = np.loadtxt('Tgas_evolution.dat', skiprows=1)  # Skip first row
z_Tgas = Tgas_data[:, 0]  # First column (redshift)
Tgas = Tgas_data[:, 1]  # Second column (gas temperature)
Tgas_interp_func = interp1d(z_Tgas, Tgas, bounds_error=False, fill_value='extrapolate')


def get_K_Tegmark97(reaction_index, T, z):
    #Table 1 in Tegmark 1997, return reaction rate in cm^3/s
    if reaction_index == 1:
        #more accurate: 6.95, 6.112, 6.116 in Peebles 1993?
        return 1.88e-10 * T**(-0.64)
    elif reaction_index == 2:
        return 1.83e-18 * T**0.88
    elif reaction_index == 3:
        return 1.3e-9
    elif reaction_index == 4:
        T_gamma = T_CMB(z)  
        return 0.114 * T_gamma**2.13 * np.exp(-8650.0 / T_gamma)
    elif reaction_index == 5:
        return 1.85e-23 * T**1.8
    elif reaction_index == 6:
        return 6.4e-10
    elif reaction_index == 7:
        T_gamma = T_CMB(z)
        return 6.36e5 * np.exp(-71600.0 / T_gamma)
    elif reaction_index == 8:
        T_gamma = T_CMB(z)
        return 4.91e-22 * T_gamma**4
    else:
        raise ValueError("Invalid reaction index. Must be an integer from 1 to 8.")

def get_km_Tegmark97(T, xe, z):
    #effective formation rate of H2
    nH = get_nH_Tegmark97(z)
    k2 = get_K_Tegmark97(2, T, z)  
    k3 = get_K_Tegmark97(3, T, z)
    k4 = get_K_Tegmark97(4, T, z)
    k5 = get_K_Tegmark97(5, T, z)
    k6 = get_K_Tegmark97(6, T, z)
    k7 = get_K_Tegmark97(7, T, z)

    k2channel_all = k3 + k4/((1-xe)*nH)
    k5channel_all = k6 + k7/((1-xe)*nH)
    km = k2*k3/k2channel_all + k5*k6/k5channel_all
    return km

def get_K_GP98(label, z):
    T_gamma = T_CMB(z)  
    if label == "H2": #HI + p --> HII + e
        Rc2 = 8.76e-11 * (1+z)**(-0.58)
        R2c = 2.41e15 * T_gamma**1.5 * np.exp(-39472/T_gamma) * Rc2
        return R2c
    elif label == "He2": #HeII + p --> HeIII + e
        return 5.0e1 * T_gamma**1.63 * np.exp(-590000/T_gamma)
    elif label == "He4": #HeI + p --> HeII + e
        return 1.0e4 * T_gamma**1.23 * np.exp(-280000/T_gamma)
    elif label == "H4": #HM + p --> HI + e
        return 1.1e-1 * T_gamma**2.13 *np.exp(-8823/T_gamma)
    elif label == "H9v0": #H2II + p --> HI + HII, v0
        return 2.0e1 * T_gamma**1.59 * np.exp(-82000/T_gamma)
    elif label == "H9LTE": #H2II + p --> HI + HII, LTE
        return 1.63e7*np.exp(-32400/T_gamma)
    elif label == "H18": #H2I + p --> H2II + e
        return 2.9e2 * T_gamma**1.56 * np.exp(-178500/T_gamma)
    elif label == "H12": #H2II + p --> 2HII + e
        return 9.0e1 * T_gamma**1.48 * np.exp(-335000/T_gamma)
    # elif label ==  #H2I + p --> 2HI
    else:
        raise ValueError("Invalid label. Must be one of 'H2', 'He2', 'He4', 'H4', 'H9v0', 'H9LTE', 'H18', 'H12'.")


def get_k1_Peebles97(T):
    T4 = T / 1e4
    k1 = 2.6e-13*T4**(-0.8)
    return k1

def get_kHM_GP98(T):
    #the reaction rate for H + e -> H- + photon [cm^3 /s], in Galli & Palla 1998 table 1

    return 1.4e-18 * T**0.928 * np.exp(-T/16200)

def get_kdiss_Yoshida03(J21, Fshield):
    return 1.38e9 * J21 *1.0e-21 * Fshield #[s^-1]

def test_k1():
    T_list = np.logspace(2, 4, 50)  # Temperature in K
    z = 15
    k1_Tegmark = np.array([get_K_Tegmark97(1, T, z) for T in T_list])
    k1_Peebles = np.array([get_k1_Peebles97(T) for T in T_list])

    fig, ax = plt.subplots(figsize=(8, 6))
    ax.plot(T_list, k1_Tegmark, label='Tegmark 1997', color='blue')
    ax.plot(T_list, k1_Peebles, label='Peebles 1993', color='red')
    ax.set_xscale('log')
    ax.set_yscale('log')
    ax.legend()
    ax.grid()
    ax.set_xlabel('Temperature [K]', fontsize=14)
    ax.set_ylabel('k1 [cm^3/s]', fontsize=14)
    
    plt.savefig("Analytic_results/Yoshida03/k1_reaction_rate_comparison.png", dpi=300)


def lgM_to_Tvir_minihalo(lgM, z):
    #lgM in Msun/h
    Tvir = Temperature_Virial_analytic(10**lgM/h_Hubble, z, mean_molecular_weight=mu_minihalo) #Tvir in K
    return Tvir

def Tvir_to_lgM_minihalo(Tvir, z):
    Mvir = inversefunc_Temperature_Virial_analytic(Tvir, z, mean_molecular_weight=mu_minihalo) #Mvir in Msun
    lgM = np.log10(Mvir * h_Hubble)  # convert to lgM [M_sun/h]
    return lgM

def get_Hubble_timescale_Tegmark97(z):
    #return Hubble timescale in Myr, modify z to 1+z for accuracy at low z
    #Tegmark 1997 Eq. 10

    return 6.5/h_Hubble * ((1+z)/100)**(-1.5)


def get_nH_Tegmark97(z):
    #Tegmark 1997 Eq. 1, modify z to 1+z for accuracy at low z
    #nH in cm^-3
    return 23*((1+z)/100)**3*h_Hubble**2*Omega_b/0.015

def get_H2abundance_formed_Tegmark97(T, z=None):
    #H2 mass fraction for Tvir
    #Tegmark 1997 Eq.17
    #T in K, return fH2
    if z is None:
        high_order_term = 0.0
    else:
        n = get_nH_Tegmark97(z)
        high_order_term = 7.4e8/n*(1+z)**2.13*np.exp(-3173/(1+z))
        # print("high_order_term = ", high_order_term)
    
    return 3.5e-4 * (T/1e3)**1.52*(1+high_order_term)**(-1)

def get_critical_H2abundance_Tegmark(T, z):
    #where cooling time = Hubble time(z), modify z to 1+z for accuracy at low z
    #Eq.11 Tegmark 1997
    T3 = T/1e3
    fc = 0.00016/(h_Hubble*Omega_b/0.03) * ((1+z)/100)**(-1.5) / (1+10*T3**3.5/(60+T3**4)) *np.exp(512/T)
    return fc
    
def get_Tvir_Tegmark97(M, z):
    #M in Msun, Tegmark Eq. 28
    return 485*h_Hubble**(2/3) * (M/1e4)**(2/3) * (1+z)/100


def get_Tvir_Yoshida03(M, z, mean_molecular_weight):
    #M in Msun
    Delta = 200
    T =  1.98e4*(mean_molecular_weight/0.6)*(M*h_Hubble/1e8)**(2/3) \
        *(Omega_m*Delta/18/np.pi**2)**(1/3)*(1+z)/10
    return T

def get_fH2_Yoshida03(T):
    #mass fraction of H2 in Tvir halo, Yoshida03 fit
    #for Tvir = 2300*(0.5**(2/3)) K, fH2 = 8e-5 (see section 4 of Yoshida 2003) 
    
    return 1.254e-9*T**1.52
def get_ss_factor_WG11(Tgas, NH2):
    x = NH2 / 5.0e14
    b5 = np.sqrt(2*kB*Tgas/2/mp)/(1e5 * 1e-2) 
    f_sh = 0.965 / (1 + x/b5)**1.1 + 0.035 / (1+x)**0.5 * np.exp(-8.5e-4*(1+x)**(1/2))
    return f_sh

def get_H2_mass_frac_equilibrium(T, nH, z, J21, self_shielding, ss_model = 'DB98'):
    if nH == None:
        lognH = get_gas_lognH_analytic(z)
        nH = 10**lognH  
    kHM = get_kHM_GP98(T)
    if self_shielding:
        fH2_without_LW = get_fH2_Yoshida03(T)
        Mvir = inversefunc_Temperature_Virial_analytic(T, z, mean_molecular_weight=mu_minihalo)  # Mvir in Msun
        halo_density = get_mass_density_analytic(z)
        halo_volume = Mvir * Msun / halo_density
        Rvir = (3 * halo_volume / (4 * np.pi))**(1/3)  # Rvir in m
        Rvir_cm = Rvir * 1e2  # Convert to cm
        if ss_model == 'DB98':
            C = 0.2
            N_H2 = C*fH2_without_LW*nH*Rvir_cm
            Fshield = min(1, (N_H2/1.0e14)**(-3/4))  # self-shielding factor, N_H2 in cm^(-2)
        elif ss_model == 'WG11':
            C = 0.2
            N_H2 = C*fH2_without_LW*nH*Rvir_cm #debug: NH2 and Tgas?
            Fshield = get_ss_factor_WG11(T, N_H2)  # self-shielding factor
        else:
            raise ValueError("Invalid self-shielding model. Must be 'DB98' or 'WG11'.")
        k_diss = get_kdiss_Yoshida03(J21, Fshield)
        # print("Rvir_cm = ", Rvir_cm, "cm, nH = ", nH, "cm^-3, N_H2 = ", N_H2, "cm^-2")
        # print("T = ", T, "K, J21 = ", J21, "Fshield = ", Fshield, "k_diss = ", k_diss)
    else:
        k_diss = get_kdiss_Yoshida03(J21, 1.0)
    xe = xe_interp_func(z)  
    ne = nH * xe
    # ne = 1e-4, debug
    f_H2_eq = 2 * kHM * ne /k_diss  #multiply by 2 to get the mass fraction of H2 in equilibrium
    return f_H2_eq

def get_H2_mass_frac_eq_Agarwal(T, nH, z, J21, spectral_type, self_shielding):

    if spectral_type == "T4":
        beta = 3; alpha = 2000
    elif spectral_type == "T5":
        beta = 0.9; alpha = 0.1

    if self_shielding:
        fH2_without_LW = get_fH2_Yoshida03(T)
        Mvir = inversefunc_Temperature_Virial_analytic(T, z, mean_molecular_weight=mu_minihalo)  # Mvir in Msun
        halo_density = get_mass_density_analytic(z)
        halo_volume = Mvir * Msun / halo_density
        Rvir = (3 * halo_volume / (4 * np.pi))**(1/3)  # Rvir in m
        Rvir_cm = Rvir * 1e2  # Convert to cm
        #use WG11, debug: NH2
        C = 0.2
        N_H2 = C*fH2_without_LW*nH*Rvir_cm #debug: NH2 and Tgas?
        Fshield = get_ss_factor_WG11(T, N_H2)  # self-shielding factor
        # print(f"T = {T} K, spectral_type = {spectral_type}, J21 = {J21}, Fshield = {Fshield}") 
    else: 
        Fshield = 1.0  # no self-shielding

    kform_1 = get_kHM_GP98(T)
    kform_2 =  get_K_Tegmark97(3, T, np.nan) 
    print("kform_1 = ", kform_1, "kform_2 = ", kform_2)
    k_HM_detach =  1.0e-10 * alpha * J21
    kform_eff = kform_1 * kform_2*nH / (kform_2*nH + k_HM_detach)
    k_H2I_diss = 1.0e-12 * beta * J21 * Fshield
    xe = xe_interp_func(z)  
    ne = nH * xe
    f_H2_eq = 2 * kform_eff * ne / k_H2I_diss  #multiply by 2 to get the mass fraction of H2 in equilibrium

    return f_H2_eq


def get_H2_mass_frac_eq_fromprofile(T, z, J21, spectral_type):
    from Grackle_Omukai import get_Jeans_length_cgs

    if spectral_type == "T4":
        beta = 3; alpha = 2000
    elif spectral_type == "T5":
        beta = 0.9; alpha = 0.1


    fH2_without_LW = get_fH2_Yoshida03(T)
    Mvir_in_Msun = inversefunc_Temperature_Virial_analytic(T, z, mean_molecular_weight=mu_minihalo)  # Mvir in Msun
    vir_mass_density = get_mass_density_analytic(z)
    
    halo_volume = Mvir_in_Msun * Msun / vir_mass_density
    Rvir = (3 * halo_volume / (4 * np.pi))**(1/3)  # Rvir in m
    Rvir_cm = Rvir * 1e2  # Convert to cm
    rho_gas_avg  = 200 * rho_b0*(1+z)**3 *Msun/Mpc**3
    rho_gas_avg_cgs = rho_gas_avg * 1e3 / (1e2)**3  # in g/cm^3
    nH_avg = rho_gas_avg/(mu_minihalo*mp)/1.0e6  #in cm^-3
    print("nH_avg = ", nH_avg, "cm^-3")

    concentration_model = 'ludlow16'
    concentration = get_concentration(Mvir_in_Msun, z, concentration_model)

    r_Rvir_list = np.logspace(-3, 0, 500)  # from 0.001 Rvir to Rvir
    x = r_Rvir_list * concentration
    # local_mass_density = density_NFW_profile(x, Mvir_in_Msun, z, concentration_model) * vir_mass_density
    # local_gas_NFW_density = gasdensity_NFW_profile(x, Mvir_in_Msun, z, concentration_model) * vir_mass_density
    local_gas_core_density = gasdensity_core_profile(x, Mvir_in_Msun, z, concentration_model) * vir_mass_density

    # local_nH_NFW_cm3 = local_gas_NFW_density/(mu*mp)/1.0e6
    local_nH_core_cm3 = local_gas_core_density/(mu_minihalo*mp)/1.0e6

    print("local_nH_core_cm3 = ", local_nH_core_cm3)


    # #use WG11, debug: NH2
    # C = 0.2
    # N_H2 = C*fH2_without_LW*nH*Rvir_cm #debug: NH2 and Tgas?
    # Fshield = get_ss_factor_WG11(T, N_H2)  # self-shielding factor
    # # print(f"T = {T} K, spectral_type = {spectral_type}, J21 = {J21}, Fshield = {Fshield}") 
    Jeans_length = get_Jeans_length_cgs(T, rho_gas_avg_cgs, mu_minihalo)
    nH2_avg = fH2_without_LW * nH_avg
    NH2 = nH2_avg * Jeans_length
    Fshield = get_ss_factor_WG11(T, NH2)
    print("Fshield = ", Fshield)



    kform_1 = get_kHM_GP98(T)
    kform_2 =  get_K_Tegmark97(3, T, np.nan) 
    # print("kform_1 = ", kform_1, "kform_2 = ", kform_2)
    k_HM_detach =  1.0e-10 * alpha * J21
    kform_eff = kform_1 * kform_2*local_nH_core_cm3 / (kform_2*local_nH_core_cm3 + k_HM_detach)
    k_H2I_diss = 1.0e-12 * beta * J21 * Fshield
    xe = xe_interp_func(z)  
    ne = local_nH_core_cm3 * xe
    f_H2_eq = 2 * kform_eff * ne / k_H2I_diss  #multiply by 2 to get the mass fraction of H2 in equilibrium

    #calculate the average fH2_eq in the halo
    fH2_eq_avg = np.trapz(f_H2_eq * local_nH_core_cm3 * 4 * np.pi * (r_Rvir_list*Rvir)**2, r_Rvir_list*Rvir) / \
        np.trapz(local_nH_core_cm3 * 4 * np.pi * (r_Rvir_list*Rvir)**2, r_Rvir_list*Rvir)


    return fH2_eq_avg




def test_Tvir():
    # compare with halo mass-Tvir in John Wise paper, R500 used in their model?
    # M_in_Msun_test = inversefunc_Temperature_Virial_analytic(7000, z, mean_molecular_weight=1.2) #Mvir in Msun
    # print("M_in_Msun_test = ", M_in_Msun_test)
    # Tvir_test = Temperature_Virial_analytic(6e6, 15, mean_molecular_weight=1.23)
    # print("Tvir_test = ", Tvir_test)


    #compare Tvir from Yoshida03, Tegmark97 and our model
    z = 20
    M_list = np.logspace(4, 8, 50)
    Tvir_Yoshida = np.array([get_Tvir_Yoshida03(M, z, 1.2) for M in M_list])
    Tvir_Tegmark = np.array([get_Tvir_Tegmark97(M, z) for M in M_list])
    Tvir_analytic = np.array([Temperature_Virial_analytic(M, z, mean_molecular_weight=mu_minihalo) for M in M_list])
    fig = plt.figure(figsize=(8, 6))
    ax = fig.add_subplot(111)
    ax.plot(M_list, Tvir_Yoshida, label='Yoshida 2003', color='blue')
    ax.plot(M_list, Tvir_Tegmark, label='Tegmark 1997', color='red')
    ax.plot(M_list, Tvir_analytic, label='our model, mu = 1.2', color='green')
    ax.set_xscale('log')
    ax.set_yscale('log')
    ax.legend()
    ax.grid()
    ax.set_xlabel('M [Msun]', fontsize=14)
    ax.set_ylabel('Tvir [K]', fontsize=14)
    ax.set_title(f'z = {z}', fontsize=14)
    plt.tight_layout()
    filename = os.path.join("Analytic_results/Yoshida03", "compare_Tvir.png")
    plt.savefig(filename, dpi=300)

    print("test Tvir, M = 1e6 Msun/h, z = 20, Tvir_Yoshida = ", get_Tvir_Yoshida03(1e6/h_Hubble, z, 1.2))
    print("test Tvir, M = 6e5 Msun/h, z = 23, Tvir_Yoshida = ", get_Tvir_Yoshida03(6e5/h_Hubble, 23, 1.2))

#check the H2 formation and dissociation timescale mentioned in Yoshida 2003
def test_H2_form_diss_timescale():
    f_H2 = 8.0e-5 #or 2.0e-4, the critical H2 fraction for the halo after merger
    nH2_over_nH = f_H2 / 2
    T = 2300
    nH = get_nH_Tegmark97(20)  
    xe = 1.0e-4
    ne = xe * nH 
    # k_HM = get_K_Tegmark97(2,T,np.nan)
    k_HM = get_kHM_GP98(T)
    t_form = nH2_over_nH/k_HM/ne
    t_form_Myr = t_form / Myr
    print("t_form = ", t_form_Myr, "Myr")


    T = 3000
    nH = 1
    z = 20.7
    J21 = 0.1
    Fshield = 1.0
    k_diss = get_kdiss_Yoshida03(J21, Fshield)  
    t_diss = 1.0 / k_diss
    t_diss_Myr = t_diss / Myr
    print("t_diss = ", t_diss_Myr, "Myr, approx", 1e12/J21/Myr, "Myr")
    fH2_eq = get_H2_mass_frac_equilibrium(T, nH, z, J21, self_shielding=False)
    print(f"fH2_eq = {fH2_eq}, using T = {T} K, nH = {nH} cm^-3 (central gas to collapse)")
    nH = 10**get_gas_lognH_analytic(z)  # get nH from analytic model
    fH2_eq = get_H2_mass_frac_equilibrium(T, None, z, J21, self_shielding=False)
    print(f"fH2_eq = {fH2_eq}, using T = {T} K, nH from get_gas_lognH_analytic(z) = {nH} cm^-3")

    #compare with O'Shea & Norman 2008, Eq.3 example
    print("\nO'Shea & Norman 2008, Eq.3 example:")
    T = 2000
    ne = 1.0e-4
    k_HM = get_kHM_GP98(T)
    F21 = 1.0
    J21 = F21 / (4 *np.pi)
    k_diss = get_kdiss_Yoshida03(J21, 1.0) 
    print("k_diss = ", k_diss, "s^-1")
    fH2 = k_HM * ne / k_diss
    print("fH2 = ", fH2)
    



def compare_Hubble_timescale_and_nH():
    z_list = np.linspace(0, 30, 100)
    t_Hubble_Tegmark = get_Hubble_timescale_Tegmark97(z_list)
    t_Hubble_colossus = np.array([cosmo.age(z)*1e3 for z in z_list])
    # print("t_Hubble_Tegmark = ", t_Hubble_Tegmark)
    # print("t_Hubble_colossus = ", t_Hubble_colossus)
    fig = plt.figure(figsize=(8, 6))
    ax = fig.add_subplot(111)
    ax.plot(z_list, t_Hubble_Tegmark, label='Tegmark 1997', color='blue')
    ax.plot(z_list, t_Hubble_colossus, label='Colossus', color='red')
    ax.set_yscale('log')
    ax.legend()
    ax.grid()
    ax.set_xlabel('z', fontsize=14)
    ax.set_ylabel('Hubble time [Myr]', fontsize=14)
    ax.set_title('Hubble time vs redshift', fontsize=16)
    plt.tight_layout()
    filename = os.path.join("Analytic_results/Yoshida03", "Hubble_time_vs_z.png")
    if not os.path.exists("Analytic_results/Yoshida03"):
        os.makedirs("Analytic_results/Yoshida03")
    plt.savefig(filename, dpi=300)

    #also compare nH in Tegmark 1997 and our model
    nH_Tegmark = get_nH_Tegmark97(z_list)
    lognH_analytic = get_gas_lognH_analytic(z_list)
    nH_Peebles = np.array([1.12e-5*Ombh2*(1+z)**3 for z in z_list])  # Peebles 1993 Eq. 1
    nH200_Peebles = np.array([1.12e-5*Ombh2*(1+z)**3*200 for z in z_list])  # Peebles 1993 Eq. 1, 200 times critical density
    nH_analytic = 10**lognH_analytic
    fig = plt.figure(figsize=(8, 6))
    ax = fig.add_subplot(111)
    ax.plot(z_list, nH_Tegmark, label='Tegmark 1997', color='blue')
    ax.plot(z_list, nH_analytic, label='our model', color='red')
    ax.plot(z_list, nH_Peebles, label='Peebles', color='green')
    ax.plot(z_list, nH200_Peebles, label='Peebles x200', color='green', linestyle='--')
    ax.set_yscale('log')
    ax.legend()
    ax.grid()
    ax.set_xlabel('z', fontsize=14)
    ax.set_ylabel('nH [cm^-3]', fontsize=14)
    ax.set_title('nH vs redshift', fontsize=16)
    plt.tight_layout()
    filename = os.path.join("Analytic_results/Yoshida03", "nH_vs_z.png")
    plt.savefig(filename, dpi=300)


def test_fH2_scaling():
    z = 20
    M = 1.0e6/h_Hubble #Msun
    T1 = get_Tvir_Yoshida03(M, z, 1.2)
    T2 = Temperature_Virial_analytic(M, z, mu_minihalo)
    print("T_vir_Yoshida03 = ", T1)
    print("T_vir_analytic = ", T2)
    print("T_vir_Yoshida03 / T_vir_analytic = ", T1/T2)

    M_test = 5.0e5/h_Hubble #Msun
    T_test = get_Tvir_Yoshida03(M_test, z, 1.2)

    fH2_test = get_fH2_Yoshida03(T_test)
    print("fH2_test = ", fH2_test)
    fH2_test_Tegmark = get_H2abundance_formed_Tegmark97(T_test)
    print("fH2_test_Tegmark = ", fH2_test_Tegmark)
    print("fH2_test / fH2_test_Tegmark = ", fH2_test/fH2_test_Tegmark)


def test_Tegmark_model():
    zvir_list = np.array([25, 50, 100])
    nH_Tegmark = get_nH_Tegmark97(zvir_list)
    print("nH_Tegmark = ", nH_Tegmark)
    T_list = np.logspace(2, 4, 50)
    All_critical_fH2 = []
    for z in zvir_list:
        fH2_critical = np.array([get_critical_H2abundance_Tegmark(T, z) for T in T_list])
        All_critical_fH2.append(fH2_critical)
    All_critical_fH2 = np.array(All_critical_fH2)
    fH2_scaling_Tegmark = np.array([get_H2abundance_formed_Tegmark97(T, z) for T in T_list])
    fH2_scaling_Yoshida = np.array([get_fH2_Yoshida03(T)/2 for T in T_list])


    #now numerically solve Tegmark's ODE and plot the final H2 abundance at z=17 
    print("Using a full list of Tvir for different zvir ...")
    xe_data_CAMB = np.loadtxt('xe_evolution.dat', skiprows=1)  # Skip first row
    z_CAMB = xe_data_CAMB[:, 0]  # First column (redshift)
    xe_CAMB = xe_data_CAMB[:, 1]  # Second column (free electron fraction)
    #do not start at very high z (z>>300) because Tegmark's xe(z) is not accurate there
    z_start = 300
    xe_interp_func = interp1d(z_CAMB, xe_CAMB, bounds_error=False, fill_value='extrapolate')
    xe_at_z_start = xe_interp_func(z_start)
    fH2_at_z_start = 1.0e-7
    z_final = 17
    Tvir_fulllist = np.logspace(np.log10(100), np.log10(5000), 30) 
    finalxe_intTegmark_allresults = []
    finalfH2_intTegmark_allresults = []
    for zvir in zvir_list:
        finalxe_for_zvir = np.zeros(len(Tvir_fulllist))
        finalfH2_for_zvir = np.zeros(len(Tvir_fulllist))
        for j, Tvir in enumerate(Tvir_fulllist):
            print("calculating Tvir = ", Tvir, "K, zvir = ", zvir)
            y_initial = np.array([xe_at_z_start, fH2_at_z_start])
            result = integrate_ode_z(dxefH2_dz_Tegmark97,z_initial=z_start,y_initial=y_initial,
                                                   z_final=z_final,ode_args=(zvir, Tvir))
            finalxe = result['y'][0][-1]  # Get the final xe value
            finalfH2 = result['y'][1][-1]  # Get the final fH2 value
            finalxe_for_zvir[j] = finalxe
            finalfH2_for_zvir[j] = finalfH2
        finalxe_intTegmark_allresults.append(finalxe_for_zvir)
        finalfH2_intTegmark_allresults.append(finalfH2_for_zvir)
    finalxe_intTegmark_allresults = np.array(finalxe_intTegmark_allresults)
    finalfH2_intTegmark_allresults = np.array(finalfH2_intTegmark_allresults)

    #plot final fH2 vs Tvir for different zvir
    

    fig = plt.figure(figsize=(8, 6))
    linestyles = ["--", ":", '-']

    for i, z in enumerate(zvir_list):
        plt.plot(T_list, All_critical_fH2[i], label='critical fraction, z='+str(z), linestyle=linestyles[i], color='k')
    plt.plot(T_list, fH2_scaling_Tegmark, label='H2 formation scaling Tegmark 1997', color='red')
    plt.plot(T_list, fH2_scaling_Yoshida, label='H2 formation scaling Yoshida 2003', color='blue')
    
    for i, zvir in enumerate(zvir_list):
        plt.plot(Tvir_fulllist, finalfH2_intTegmark_allresults[i], 
                label=f'zvir={zvir}', color='green', linestyle=linestyles[i])
    
    
    plt.xscale('log')
    plt.yscale('log')
    plt.xlabel('T [K]')
    plt.ylabel('n(H2)/n(H)')
    plt.title('Tegmark 1997 model')
    plt.legend()
    plt.tight_layout()
    filename = os.path.join("Analytic_results/Yoshida03", "Tegmark_fH2_vs_T_z.png")
    plt.savefig(filename, dpi=300)

def x_t_Tegmark97(x0, t, n, T):
    k1 = get_K_Tegmark97(1, T, 0)  # k1 doesn't depend on z in this case
    x_t = x0/(1+x0*n*k1*t)
    return x_t

def dxe_dz_Tegmark97(z, xe, T):
    T = Tgas_interp_func(z)  # debug: reset T to Tgas at redshift z
    # T = 5000
    nH = get_nH_Tegmark97(z)/200 #debug/200
    k1 = get_K_Tegmark97(1, T, z)
    dxe_dt = - k1 * nH * xe**2
    Hz = cosmo.Hz(z)/3.086e19  #convert km/s/Mpc to s^(-1)
    dt_dz = -1/(1+z)/Hz
    dxe_dz = dxe_dt * dt_dz
    return dxe_dz

def dxe_dz_Peebles99(z, xe):
    T = T_CMB(z)
    T4 = T / 1e4
    nH = 1.12e-5 * Ombh2 * (1+z)**3  # Peebles 1993 Eq. 1
    # nH =  get_nH_Tegmark97(z)/200
    # lognH = get_gas_lognH_analytic(z)
    # nH  = 10**lognH/200  
    alpha_e = 2.6e-13* T4**(-0.8) 
    Lambda_2s = 8.23 #s^(-1), the two-photon decay rate from metastable state 2s to ground state
    beta_e_over_Lambda = 8e7*T4**0.7*np.exp(-3.95/T4)
    beta_e = beta_e_over_Lambda * Lambda_2s
    C_approx = 1.0/(1.0+beta_e_over_Lambda)
    h_nualpha = 10.2*eV
    exp_factor = np.exp(-h_nualpha/(T*kB))
    dxe_dt = - C_approx*(alpha_e*xe**2*nH -beta_e*(1-xe)*exp_factor)
    Hz = cosmo.Hz(z)/3.086e19  #convert km/s/Mpc to s^(-1)
    dt_dz = -1/(1+z)/Hz
    dxe_dz = dxe_dt * dt_dz
    return dxe_dz

def dxefH2_dz_Tegmark97(z, y, z_vir, T_vir):
    xe = y[0]
    fH2 = y[1]
    if z >= z_vir:
        T = Tgas_interp_func(z)
        nH = get_nH_Tegmark97(z)/200
        # return np.array([0, 0])  #Another option: do not evolve before virialization (has little effect on final result)      
    else:
        T = T_vir
        nH = get_nH_Tegmark97(z)
    k1 = get_K_Tegmark97(1, T, z)
    km = get_km_Tegmark97(T, xe, z)
    dxe_dt = - k1 * nH * xe**2
    dfH2_dt = km * nH * (1 - xe - 2*fH2) * xe
    Hz = cosmo.Hz(z)/3.086e19  
    dt_dz = -1/(1+z)/Hz
    dxe_dz = dxe_dt * dt_dz
    dfH2_dz = dfH2_dt * dt_dz
    return np.array([dxe_dz, dfH2_dz])
    

def plot_xefH2_vs_z():#debug: n and T fixed?

    xe_data_CAMB = np.loadtxt('xe_evolution.dat', skiprows=1)  # Skip first row
    z_CAMB = xe_data_CAMB[:, 0]  # First column (redshift)
    xe_CAMB = xe_data_CAMB[:, 1]  # Second column (free electron fraction)
    #do not start at very high z (z>>300) because Tegmark's xe(z) is not accurate there
    z_start = 300
    xe_interp_func = interp1d(z_CAMB, xe_CAMB, bounds_error=False, fill_value='extrapolate')
    xe_at_z_start = xe_interp_func(z_start)
    fH2_at_z_start = 1.0e-7
    print(f"xe at z = {z_start} is {xe_at_z_start}")
    print(f"fH2 at z = {z_start} is {fH2_at_z_start}")

    z_final = 15

    xe_intPeebles_result = integrate_ode_z(dxe_dz_Peebles99, z_initial=1800, y_initial=1.0, z_final=z_final)
    # print("xe_intPeebles_result = ", xe_intPeebles_result)

    #use Tgas(z) throughout the integration
    xefH2_intTegmark_Tgas = integrate_ode_z(dxefH2_dz_Tegmark97, z_initial=z_start, 
                                            y_initial=np.array([xe_at_z_start, fH2_at_z_start]),
                                            z_final = 15, ode_args=(-1.0 , np.nan))
    
    # print("xefH2_intTegmark_Tgas = ", xefH2_intTegmark_Tgas)


    Tvir_list = [100, 1000, 3000]
    zvir_list = [25, 50, 100]
    


    # z_list = np.logspace(np.log10(15), np.log10(z_start), 1000)
    # t_list_colossus = np.array([cosmo.age(z) for z in z_list]) * 1e3 * Myr  # Convert to s
    # nH_list = np.array([get_nH_Tegmark97(z) for z in z_list])
    # print("z_list = ", z_list)
    # print("t_list_colossus = ", t_list_colossus)
    # print("nH_list = ", nH_list)

        # x_t_results = x_t_Tegmark97(x0, t_list_colossus, n, T)
    
    #2. xe(z) from integration of Eq. 12 in Tegmark 1997
    xefH2_intTegmark_allresults = []
    for Tvir in Tvir_list:
        for zvir in zvir_list:
            print("calculating Tvir = ", Tvir, "K, zvir = ", zvir)
            y_initial = np.array([xe_at_z_start, fH2_at_z_start]) #debug: initial fH2 ?
            result = integrate_ode_z(dxefH2_dz_Tegmark97, 
                                                   z_initial=z_start, 
                                                   y_initial=y_initial, 
                                                   z_final=z_final,
                                                   ode_args=(zvir, Tvir))
            # print("result (xe, fH2): ", result['y'])
            xefH2_intTegmark_allresults.append(result)

    colors = ['b', 'g', 'r']
    linestyles = ["--", ":", '-']

    #plot xe(z)
    fig, ax = plt.subplots(figsize=(8, 6))
    CAMB_mask = (z_CAMB > 15) & (z_CAMB < 1800)
    ax.plot(z_CAMB[CAMB_mask], xe_CAMB[CAMB_mask], label='CAMB data', color='k', linestyle='-')
    ax.plot(xe_intPeebles_result['z'], xe_intPeebles_result['y'][0], label='Peebles 1999', color='orange', linestyle='--')
    ax.plot(xefH2_intTegmark_Tgas['z'], xefH2_intTegmark_Tgas['y'][0], label='Tegmark+Tgas model', color='purple', linestyle='-.')
    # marker_list = ['o', 's', 'x'] #for each zvir  
    for i in range(len(Tvir_list)):
        for j in range(len(zvir_list)):
            result = xefH2_intTegmark_allresults[i*len(zvir_list) + j]
            z = result['z']
            xe = result['y'][0]
            label = f'Tegmark+ Tvir={Tvir_list[i]} K, zvir={zvir_list[j]}'
            ax.plot(z, xe, label=label, color=colors[i], linestyle=linestyles[j])

            # t = np.array([cosmo.age(_z) for _z in z]) * 1e3 * Myr  # Convert to s
            # x_t = np.array([x_t_Tegmark97(3.0e-4, _t, get_nH_Tegmark97(zvir_list[j]), Tvir_list[i]) for _t in t])
            # ax.scatter(z[::50], x_t[::50], color=colors[i], marker=marker_list[j], s=10)  
            
    ax.invert_xaxis()
    ax.set_xscale('log')
    ax.set_yscale('log')
    ax.set_xlabel('Redshift (z)', fontsize=14)
    ax.set_ylabel('Ionization Fraction (xe)', fontsize=14)
    ax.grid()
    ax.legend()
    plt.tight_layout()
    filename = os.path.join("Analytic_results/Yoshida03", f"xe_vs_z.png")
    plt.savefig(filename, dpi=300)

    #also plot fH2(z)
    fig, ax = plt.subplots(figsize=(8, 6))
    ax.plot(xefH2_intTegmark_Tgas['z'], xefH2_intTegmark_Tgas['y'][1], label='Tegmark+Tgas model', color='purple', linestyle='-.')
    for i in range(len(Tvir_list)):
        for j in range(len(zvir_list)):
            result = xefH2_intTegmark_allresults[i*len(zvir_list) + j]
            z = result['z']
            fH2 = result['y'][1]
            label = f'Tegmark+ Tvir={Tvir_list[i]} K, zvir={zvir_list[j]}'
            ax.plot(z, fH2, label=label, color=colors[i], linestyle=linestyles[j])
    ax.invert_xaxis()
    ax.set_xscale('log')
    ax.set_yscale('log')
    ax.set_xlabel('Redshift (z)', fontsize=14)
    ax.set_ylabel('n(H2)/n(H)', fontsize=14)
    ax.grid()
    ax.legend()
    plt.tight_layout()
    filename = os.path.join("Analytic_results/Yoshida03", f"fH2_vs_z.png")
    plt.savefig(filename, dpi=300)


#plot the H2 mass fraction vs Tvir for Yoshida 2003 model
def plot_Yoshida03_fH2_vs_Tvir():
    Tvir_fulllist = np.logspace(np.log10(100), np.log10(8000), 50) 

    z_final = 17
    # finalxe_zvir25 = finalxe_intTegmark_allresults[0]
    nHhalo_zfinal = get_nH_Tegmark97(z_final)
    fH2_Yoshida03 = get_fH2_Yoshida03(Tvir_fulllist)

    fH2_Yoshida03_LWhigh = np.zeros(len(Tvir_fulllist))
    fH2_Yoshida03_LWlow_shield = np.zeros(len(Tvir_fulllist))
    fH2_Yoshida03_LWlow = np.zeros(len(Tvir_fulllist))
    for i, Tvir in enumerate(Tvir_fulllist):
        fH2_Yoshida03_LWhigh[i] = get_H2_mass_frac_equilibrium(Tvir, None, z_final, 0.1, self_shielding=False)
        fH2_Yoshida03_LWlow_shield[i] = get_H2_mass_frac_equilibrium(Tvir, None, z_final, 0.01, self_shielding=True)
        fH2_Yoshida03_LWlow[i] = get_H2_mass_frac_equilibrium(Tvir, None, z_final, 0.01, self_shielding=False)
    
    fig = plt.figure(figsize=(8, 6))
    ax = fig.gca()
    ax.plot(Tvir_fulllist, fH2_Yoshida03, label='Yoshida 2003', color='blue', linestyle='-')
    mask = (Tvir_fulllist > 200)
    ax.plot(Tvir_fulllist[mask], fH2_Yoshida03_LWhigh[mask], label='Yoshida 2003 LW(J21 = 0.1)', color='green', linestyle='--')
    ax.plot(Tvir_fulllist[mask], fH2_Yoshida03_LWlow_shield[mask], label='Yoshida 2003 LW(J21 = 0.01) with self-shielding', color='green', linestyle='-.')
    ax.plot(Tvir_fulllist[mask], fH2_Yoshida03_LWlow[mask], label='Yoshida 2003 LW(J21 = 0.01)', color='green', linestyle=':')
    ax.set_xscale('log')
    ax.set_yscale('log')
    ax.set_xlabel('Tvir [K]', fontsize=14)
    ax.set_ylabel(f'H2 mass fraction at z = {z_final}', fontsize=14)
    ax.set_ylim(1e-8, 2e-2)
    ax.grid()
    ax.legend()
    plt.tight_layout()
    filename = os.path.join("Analytic_results/Yoshida03", f"Yoshida03_fH2_vs_Tvir.png")
    plt.savefig(filename, dpi=300)

#find the critical fH2 for each T
def find_critical_fH2(timescale_array, initial_fH2_list, T_list, t_Hubble_Myr):
    fH2_critical = np.ones(len(T_list))
    
    for i in range(len(T_list)):
        found = False
        for j in range(len(initial_fH2_list) - 1, 0, -1):
            ct1 = timescale_array[i, j]
            ct2 = timescale_array[i, j - 1]
            if (not np.isnan(ct1)) and (not np.isnan(ct2)):
                if ct1 < 0.0 and ct2 < 0.0:
                    if -ct1 <= t_Hubble_Myr and -ct2 > t_Hubble_Myr:
                        fH2_critical[i] = initial_fH2_list[j]
                        found = True
                        break
                elif ct1 <0.0 and ct2 > 0.0 and -ct1 <= t_Hubble_Myr:
                    fH2_critical[i] = initial_fH2_list[j]
                    found = True
                    break
        if not found:
            if np.all(np.isnan(timescale_array[i, :])): #all nan, near 1e4K
                fH2_critical[i] = initial_fH2_list[0]
            elif 0 < np.nanmax(-timescale_array[i, :]) < t_Hubble_Myr:
                fH2_critical[i] = initial_fH2_list[0]
            elif np.nanmin(-timescale_array[i, :]) > t_Hubble_Myr or np.nanmax(timescale_array[i, :])> 0.0: #max cooling not enough or all net heating
                fH2_critical[i] = initial_fH2_list[-1]
                
    return fH2_critical

#auxiliary function to add a mass axis on top of the temperature axis 
def add_mass_axis_on_top(ax1, T_list, z, Tvir_to_lgM, lgM_to_Tvir):
    """
    add a mass axis on top of the temperature axis in ax1
    Parameters:
    - ax1: matplotlib Axes object with temperature axis
    - T_list: Tvir list [K]
    - z: redshift
    - Tvir_to_lgM: function, Tvir -> log10(M)
    - lgM_to_Tvir: function, log10(M) -> Tvir
    returns:
    - ax2: new Axes object with mass axis
    """
    ax2 = ax1.twiny()
    ax2.set_xlim(ax1.get_xlim())
    ax2.set_xscale('log')

    lgM_min = Tvir_to_lgM(min(T_list), z)
    lgM_max = Tvir_to_lgM(max(T_list), z)
    desired_log_masses = np.arange(int(np.floor(lgM_min)), int(np.ceil(lgM_max)) + 1)

    T_ticks_top = [lgM_to_Tvir(lgM, z) for lgM in desired_log_masses]
    valid_data = [(Tvir, 10**lgM, lgM) for Tvir, lgM in zip(T_ticks_top, desired_log_masses)
                if min(T_list) <= Tvir <= max(T_list)]

    if valid_data:
        T_ticks_top, M_ticks, log_masses = zip(*valid_data)
        # Set major ticks on top axis
        ax2.set_xticks(T_ticks_top)
        mass_labels = [f"$10^{{{int(lgM)}}}$" for lgM in log_masses]
        ax2.set_xticklabels(mass_labels)
        ax2.xaxis.set_major_locator(FixedLocator(T_ticks_top))
        
        # Generate minor ticks for mass axis
        minor_tick_temps = []
        if log_masses:
            first_lgM = log_masses[0]
            prev_lgM = first_lgM - 1  # Previous decade
            for multiplier in [2, 3, 4, 5, 6, 7, 8, 9]:
                minor_mass_lgM = prev_lgM + np.log10(multiplier)
                minor_temp = lgM_to_Tvir_minihalo(minor_mass_lgM, z)
                if min(T_list) <= minor_temp <= max(T_list):
                    minor_tick_temps.append(minor_temp)
        for i in range(len(log_masses)):
            current_lgM = log_masses[i]
            for multiplier in [2, 3, 4, 5, 6, 7, 8, 9]:
                minor_mass_lgM = current_lgM + np.log10(multiplier)
                minor_temp = lgM_to_Tvir_minihalo(minor_mass_lgM, z)
                if min(T_list) <= minor_temp <= max(T_list):
                    minor_tick_temps.append(minor_temp)
        
        # Set minor ticks
        ax2.xaxis.set_minor_locator(FixedLocator(minor_tick_temps))
        ax2.set_xlabel(r'Mvir [M$_\odot$/h] (z = ' + str(z) + ')', fontsize=15)
        ax2.tick_params(labelsize=12)
        ax2.tick_params(axis='x', which='minor', labelbottom=False, labeltop=False)

    return ax2

def plot_fH2_vs_T(z):

    output_dir = "/home/zwu/21cm_project/unified_model/Analytic_results/Yoshida03"

    #test different Hubble timescale
    t_Hubble_Tegmark = get_Hubble_timescale_Tegmark97(z)
    t_Hubble_colossus = cosmo.age(z)*1e3
    print(f"t_Hubble_Tegmark = {t_Hubble_Tegmark} Myr")
    print(f"t_Hubble_colossus = {t_Hubble_colossus} Myr")
    # t_Hubble_Myr = get_Hubble_timescale_Tegmark97(z)
    t_Hubble_Myr = t_Hubble_colossus
    # t_Hubble_Myr = 1.0/H0_s/Myr

    lognH = get_gas_lognH_analytic(z)
    # lognH = np.log10(500)
    print("lognH = ", lognH)
    nH = 10**lognH
    print("nH = ", nH)


    #plot fH2 vs T
    T_list = np.logspace(2, np.log10(8500), 50)
    initial_fH2_list = np.logspace(-6, -1, 100)

    target_fH2_list = np.logspace(-6, -1, 100)
    log_fH2_targets = np.log10(target_fH2_list)
    cooling_rate_for_initial_fH2 = np.zeros(len(initial_fH2_list))
    cooling_timescale_for_initial_fH2 = np.zeros(len(initial_fH2_list))
    final_fH2_all = np.zeros((len(T_list), len(initial_fH2_list)))
    final_fHM_all = np.zeros((len(T_list), len(initial_fH2_list))) #for debug
    final_fH2II_all = np.zeros((len(T_list), len(initial_fH2_list))) #for debug

    cooling_timescale_all = np.zeros((len(T_list), len(target_fH2_list)))
    cooling_rate_all = np.zeros((len(T_list), len(target_fH2_list)))

    #first loop over T_list, then initial_fH2_list
    for i in range(len(T_list)):
        Tvir = T_list[i]
        print("Tvir = ", Tvir)
        for j in range(len(initial_fH2_list)):
            fH2 = initial_fH2_list[j]

            params_for_constdensity = {
                "evolve_cooling": False,
                "redshift": z,
                "lognH": lognH,
                "specific_heating_rate": 0.0,
                "volumetric_heating_rate": 0.0,
                "temperature": Tvir,
                "gas_metallicity": 0.0,
                "f_H2": fH2
            }
            cooling_data = run_constdensity_model(
                params_for_constdensity, UVB_flag=False, 
                Compton_Xray_flag=False, dynamic_final_flag=False, converge_when_setup=True)
            cooling_time = cooling_data['cooling_time']
            cooling_timescale_for_initial_fH2[j] = cooling_time.in_units('Myr')[0].v
            cooling_rate_for_initial_fH2[j] = cooling_data['cooling_rate'][0].v
            final_fH2_all[i, j] = cooling_data['H2I_density'][0].v/cooling_data['density'][0].v
            final_fHM_all[i, j] = cooling_data['HM_density'][0].v/cooling_data['density'][0].v #for debug
            final_fH2II_all[i, j] = cooling_data['H2II_density'][0].v/cooling_data['density'][0].v #for debug
        print("final_fH2 = ", final_fH2_all[i, :])
        # print("final_fHM = ", final_fHM_all[i, :]) #for debug
        # print("final_fH2II = ", final_fH2II_all[i, :]) #for debug
        # print("cooling_timescale_for_initial_fH2 = ", cooling_timescale_for_initial_fH2)


        #interpolate cooling rate and cooling timescale as a function of final fH2
        sorted_indices = np.argsort(final_fH2_all[i, :])
        sorted_final_fH2 = final_fH2_all[i, :][sorted_indices]
        sorted_cooling_timescales = cooling_timescale_for_initial_fH2[sorted_indices]
        sorted_cooling_rates = cooling_rate_for_initial_fH2[sorted_indices]
        valid_mask = (
            (sorted_cooling_timescales < 0) &
            (sorted_cooling_rates < 0)
        )
        x = np.log10(sorted_final_fH2[valid_mask])
        y_timescale = np.log10(np.abs(sorted_cooling_timescales[valid_mask]))
        y_rate = np.log10(np.abs(sorted_cooling_rates[valid_mask]))
        interp_timescale_log = interp1d(x, y_timescale, bounds_error=False, fill_value=np.nan)
        interp_rate_log = interp1d(x, y_rate, bounds_error=False, fill_value=np.nan)

        interpolated_timescale = 10 ** interp_timescale_log(log_fH2_targets)
        interpolated_rate = 10 ** interp_rate_log(log_fH2_targets)
        cooling_timescale_all[i, :] = -interpolated_timescale
        # print("interpolated_timescale = ", -interpolated_timescale)
        cooling_rate_all[i, :] = -interpolated_rate
        # print("interpolated_rate = ", -interpolated_rate)



    # print("cooling_timescale_all = ", cooling_timescale_all)
    # print("cooling_rate_all = ", cooling_rate_all)
    # print("energy in the unit cell = ",cooling_timescale_all*cooling_rate_all) 

    #include DF heating
    print("Calculating DF heating...")
    DF_heating_list = np.zeros(len(T_list))
    normalized_heating_list = np.zeros(len(T_list))
    for i in range(len(T_list)):
        Tvir = T_list[i]
        M_in_Msun = inversefunc_Temperature_Virial_analytic(Tvir, z, mean_molecular_weight=mu_minihalo) #Mvir in Msun
        Mvir = M_in_Msun * h_Hubble #Msun/h
        lgM = np.log10(Mvir)
        DF_heating = integrate_SHMF_heating_for_single_host(z, -3, 0, lgM, "BestFit_z",mean_molecular_weight=mu_minihalo)
        DF_heating_erg = DF_heating * 1.0e7 # erg/s
        halo_density = get_mass_density_analytic(z)
        halo_volume = M_in_Msun * Msun / halo_density
        halo_volume_cm3 = halo_volume * 1.0e6 # cm^3
        DF_heating_density = DF_heating_erg / halo_volume_cm3 # erg/s/cm^3
        normalized_heating = DF_heating_density/nH**2 # erg/s*cm^3

        DF_heating_list[i] = DF_heating_density
        normalized_heating_list[i] = normalized_heating
    
    cooling_rate_with_DF_all = np.full((len(T_list), len(initial_fH2_list)), np.nan)
    cooling_timescale_with_DF_all = np.full((len(T_list), len(initial_fH2_list)), np.nan)

    for i in range(len(T_list)):
        for j in range(len(initial_fH2_list)):
            cooling_rate = cooling_rate_all[i, j]
            cooling_timescale = cooling_timescale_all[i, j]
            
            if not np.isnan(cooling_rate) and not np.isnan(cooling_timescale):
                energy_density_in_cell = cooling_rate * cooling_timescale
                #debug factor * DF heating
                cooling_rate_with_DF = cooling_rate + normalized_heating_list[i]
                cooling_rate_with_DF_all[i, j] = cooling_rate_with_DF

                if cooling_rate_with_DF != 0:
                    cooling_timescale_with_DF = energy_density_in_cell / cooling_rate_with_DF
                    cooling_timescale_with_DF_all[i, j] = cooling_timescale_with_DF
    
    #find where cooling_rate_with_DF crosses zero
    fH2_zero_netcooling = np.full(len(T_list), np.nan)  # Store fH2 values where cooling rate crosses zero
    for i in range(len(T_list)):
        for j in range(len(initial_fH2_list) - 1, 0, -1):
            ct1 = cooling_rate_with_DF_all[i, j]
            ct2 = cooling_rate_with_DF_all[i, j - 1]
            if (not np.isnan(ct1)) and (not np.isnan(ct2)):
                if ct1 < 0.0 and ct2 > 0.0:
                    # Interpolate to find the fH2 where cooling rate crosses zero
                    fH2_zero_netcooling[i] = initial_fH2_list[j]
                    break
            if np.all(np.isnan(cooling_rate_with_DF_all[i, :])): #all nan, near 1e4K
                fH2_zero_netcooling[i] = initial_fH2_list[0]
            elif np.nanmax(cooling_rate_with_DF_all[i, :]) < 0.0: #all negative (net cooling)
                fH2_zero_netcooling[i] = initial_fH2_list[0]
            elif np.nanmin(cooling_rate_with_DF_all[i, :]) > 0.0: #all positive (net heating)
                fH2_zero_netcooling[i] = initial_fH2_list[-1]
    

    fH2_critical = find_critical_fH2(cooling_timescale_all, initial_fH2_list, T_list, t_Hubble_Myr)
    fH2_with_DF_critical = find_critical_fH2(cooling_timescale_with_DF_all, initial_fH2_list, T_list, t_Hubble_Myr)

    fH2_Yoshida = get_fH2_Yoshida03(T_list)
    fH2_critical_Tegmark = np.array([get_critical_H2abundance_Tegmark(T, z) for T in T_list])
    line_styles = {
    'tegmark_crit': {'color': 'darkgreen', 'linestyle': '-', 'linewidth': 2.5, 
                'label': 'Critical line (Tegmark97)'},
    'grackle_crit': {'color': 'black', 'linestyle': '-', 'linewidth': 2, 
                'label': 'Critical line (Grackle)'},
    'grackle_df_crit': {'color': 'orange', 'linestyle': '-', 'linewidth': 2, 
                   'label': 'Critical line with DF heating (Grackle)'},
    'yoshida_H2produced': {'color': 'dimgray', 'linestyle': '--', 'linewidth': 2, 
                'label': r'H$_2$ $\propto$ T$^{1.52}$ (Yoshida03, z=17)'},
    'zero_netcooling': {'color': 'magenta', 'linestyle': ':', 'linewidth': 2,
                'label': 'cooling = DF heating'},
    }

    print("cooling with DF = ", cooling_rate_with_DF_all)
    print("max cooling with DF = ", np.nanmax(cooling_rate_with_DF_all))
    print("min cooling with DF = ", np.nanmin(cooling_rate_with_DF_all))
    print("min(abs(cooling rate with DF)) = ", np.nanmin(np.abs(cooling_rate_with_DF_all)))


    print("cooling timescale with DF = ", cooling_timescale_with_DF_all)
    print("max cooling timescale with DF = ", np.nanmax(cooling_timescale_with_DF_all))
    print("min cooling timescale with DF = ", np.nanmin(cooling_timescale_with_DF_all))
    print("min(abs(cooling timescale with DF)) = ", np.nanmin(np.abs(cooling_timescale_with_DF_all)))
    




    T_grid, fH2_grid = np.meshgrid(T_list, initial_fH2_list, indexing='ij')

    #1. 2D color plot for cooling rate
    masked_lg_cooling_rate = np.ma.masked_invalid(np.log10(-cooling_rate_all))
    fig, ax1 = plt.subplots(figsize=(9, 7)) 
    cmap = plt.colormaps['seismic_r'].copy()
    cmap.set_bad(color='lightgray') 
    c = plt.pcolormesh(
    T_grid, fH2_grid, masked_lg_cooling_rate, 
    cmap=cmap, shading='auto',
    vmin=np.nanmin(masked_lg_cooling_rate), vmax=np.nanmax(masked_lg_cooling_rate)
    )
    cb = plt.colorbar(c)
    cb.set_label(r'log$_{10}$(cooling rate [erg cm$^3$ /s])', fontsize=14)
    mask_1e4 = (T_list <= 1e4)
    # ax1.plot(T_list[mask_1e4], fH2_critical_Tegmark[mask_1e4], **line_styles['tegmark_crit'])
    ax1.plot(T_list, fH2_critical, **line_styles['grackle_crit'])
    ax1.plot(T_list, fH2_with_DF_critical, **line_styles['grackle_df_crit'])
    ax1.plot(T_list[mask_1e4], fH2_Yoshida[mask_1e4], **line_styles['yoshida_H2produced'])
    # ax1.plot(T_list, fH2_zero_netcooling, **line_styles['zero_netcooling'])
    ax1.set_ylim(1e-6, 1e-2)
    ax1.set_xscale('log')
    ax1.set_yscale('log')
    ax1.set_xlabel('Tvir [K]', fontsize=15)
    ax1.set_ylabel('H${_2}$ mass fraction', fontsize=15)
    legend = ax1.legend(fontsize=14, framealpha=0.5)
    ax2 = add_mass_axis_on_top(ax1, T_list, z, Tvir_to_lgM_minihalo, lgM_to_Tvir_minihalo)
    # plt.title('Cooling Rate vs Temperature and H${_2}$ mass fraction',fontsize=16)
    plt.tight_layout()
    plt.savefig(os.path.join(output_dir, f"cooling_rate_vs_T_fH2_z{z}.png"), dpi=300)
    print(f"Cooling rate plot saved to {os.path.join(output_dir, f'cooling_rate_vs_T_fH2_z{z}.png')}")

    exit()

    #2. plot the cooling rate with DF heating
    linthresh = 1e-30  # use linear scale between -linthresh and linthresh, otherwise log scale
    net_cooling_with_DF_all = - cooling_rate_with_DF_all
    vmax = np.nanmax(np.abs(net_cooling_with_DF_all))
    vmin = -vmax
    masked_cooling_rate = np.ma.masked_invalid(net_cooling_with_DF_all)

    fig, ax1 = plt.subplots(figsize=(9, 7))
    cmap = plt.colormaps['seismic_r'].copy()
    cmap.set_bad(color='lightgray')

    c = plt.pcolormesh(
        T_grid, fH2_grid, masked_cooling_rate,
        cmap=cmap, shading='auto',
        norm=SymLogNorm(linthresh=linthresh, vmin=vmin, vmax=vmax)
    )
    cb = plt.colorbar(c, label=r'Net Cooling Rate [erg cm$^3$/s]')
    mask_1e4 = (T_list <= 1e4)
    ax1.plot(T_list[mask_1e4], fH2_critical_Tegmark[mask_1e4], **line_styles['tegmark_crit'])
    ax1.plot(T_list, fH2_critical, **line_styles['grackle_crit'])
    ax1.plot(T_list, fH2_with_DF_critical, **line_styles['grackle_df_crit'])
    ax1.plot(T_list[mask_1e4], fH2_Yoshida[mask_1e4], **line_styles['yoshida_H2produced'])
    ax1.plot(T_list, fH2_zero_netcooling, **line_styles['zero_netcooling'])
    ax1.set_ylim(1e-6, 1e-1)
    ax1.set_xscale('log')
    ax1.set_yscale('log')
    ax1.set_xlabel('Temperature [K]', fontsize=15)
    ax1.set_ylabel('Molecular Hydrogen Fraction $f_{H_2}$', fontsize=15)
    legend = ax1.legend(fontsize=11, framealpha=0.5)
    ax2 = add_mass_axis_on_top(ax1, T_list, z, Tvir_to_lgM_minihalo, lgM_to_Tvir_minihalo)
    plt.title('Cooling - DF Heating')
    plt.tight_layout()
    plt.savefig(os.path.join(output_dir, f"cooling_rate_vs_T_fH2_z{z}_withDF.png"), dpi=300)



    exit()

    #3. 2D color plot for cooling timescale
    masked_lg_cooling_timescale_all = np.ma.masked_invalid(np.log10(-cooling_timescale_all))
    fig, ax1 = plt.subplots(figsize=(9, 7)) 
    cmap = plt.colormaps['seismic'].copy()
    cmap.set_bad(color='lightgray')  
    c = ax1.pcolormesh(
        T_grid, fH2_grid, masked_lg_cooling_timescale_all, 
        cmap=cmap, shading='auto',
        vmin=np.min(masked_lg_cooling_timescale_all), vmax=np.max(masked_lg_cooling_timescale_all)
    )
    cb = plt.colorbar(c, ax=ax1, label=r'log$_{10}$(cooling timescale [Myr])',shrink=1.0, pad=0.02)  
    cb.ax.tick_params(labelsize=14)  

    mask_1e4 = (T_list <= 1e4)
    ax1.plot(T_list[mask_1e4], fH2_critical_Tegmark[mask_1e4], **line_styles['tegmark_crit'])
    ax1.plot(T_list, fH2_critical, **line_styles['grackle_crit'])
    ax1.plot(T_list, fH2_with_DF_critical, **line_styles['grackle_df_crit'])
    ax1.plot(T_list[mask_1e4], fH2_Yoshida[mask_1e4], **line_styles['yoshida_H2produced'])
    ax1.plot(T_list, fH2_zero_netcooling, **line_styles['zero_netcooling'])
    # ax1.plot(T_list[T_list<=1e4], fH2_Tegmark[T_list<=1e4], color='k', linestyle='--', label='H2 fraction produced (Tegmark97)')
    ax1.set_ylim(1e-6, 1e-1)
    ax1.set_xscale('log')
    ax1.set_yscale('log')
    ax1.set_xlabel('Temperature [K]', fontsize=16)
    ax1.set_ylabel(r'Molecular Hydrogen Fraction $f_{\mathrm{H_2}}$', fontsize=16)
    ax1.tick_params(labelsize=12)
    legend = ax1.legend(fontsize=11, framealpha=0.5)
    ax2 = add_mass_axis_on_top(ax1, T_list, z, Tvir_to_lgM_minihalo, lgM_to_Tvir_minihalo)
    title_text = (f'Cooling Timescale vs Temperature and $f_{{\mathrm{{H_2}}}}$ at z = {z}\n'
              f'(Hubble time = {t_Hubble_Myr:.0f} Myr)')
    plt.title(title_text, fontsize=16, pad=20)
    plt.tight_layout()
    plt.savefig(os.path.join(output_dir, f"cooling_timescale_vs_T_fH2_z{z}.png"), dpi=300)
    


    #4. plot the cooling timescale with DF heating
    # linthresh = 1.0
    masked_cooling_timescale_with_DF = np.ma.masked_invalid(-cooling_timescale_with_DF_all)
    display_data = masked_cooling_timescale_with_DF.copy()
    lg_display_data = display_data.copy()
    lg_display_data[display_data > 0] = np.log10(display_data[display_data > 0])
    lg_display_data[display_data <= 0] = -9999  # set negative values to -9999 for display
    lg_display_data = np.ma.masked_where(np.isnan(masked_cooling_timescale_with_DF), lg_display_data)
    cmap = plt.colormaps['seismic'].copy()
    cmap.set_bad(color='lightgray')    # NaNs
    cmap.set_under('black') #for net heating, where cooling timescale doesn't exist
    fig, ax1 = plt.subplots(figsize=(9, 7))
    cmap = plt.colormaps['seismic'].copy()
    cmap.set_bad(color='lightgray')  
    c = ax1.pcolormesh(
        T_grid, fH2_grid, lg_display_data,
        cmap=cmap, shading='auto',
        vmin=0.0  
    )
    cb = plt.colorbar(c, ax=ax1, label=r'log$_{10}$(net cooling timescale [Myr])',shrink=1.0, pad=0.02)  
    cb.ax.tick_params(labelsize=14)  

    mask_1e4 = (T_list <= 1e4)
    ax1.plot(T_list[mask_1e4], fH2_critical_Tegmark[mask_1e4], **line_styles['tegmark_crit'])
    ax1.plot(T_list, fH2_critical, **line_styles['grackle_crit'])
    ax1.plot(T_list, fH2_with_DF_critical, **line_styles['grackle_df_crit'])
    ax1.plot(T_list[mask_1e4], fH2_Yoshida[mask_1e4], **line_styles['yoshida_H2produced'])
    ax1.plot(T_list, fH2_zero_netcooling, **line_styles['zero_netcooling'])
    ax1.set_ylim(1e-6, 1e-1)
    ax1.set_xscale('log')
    ax1.set_yscale('log')
    ax1.set_xlabel('Temperature [K]', fontsize=15)
    ax1.set_ylabel('Molecular Hydrogen Fraction $f_{H_2}$', fontsize=15)
    legend = ax1.legend(fontsize=11, framealpha=0.5)
    ax2 = add_mass_axis_on_top(ax1, T_list, z, Tvir_to_lgM_minihalo, lgM_to_Tvir_minihalo)
    plt.title('Cooling Timescale (with DF) vs Temperature and $f_{H_2}$')
    plt.tight_layout()
    plt.savefig(os.path.join(output_dir, f"cooling_timescale_vs_T_fH2_z{z}_withDF.png"), dpi=300)



  


    #save cooling rate and cooling timescale to txt file
    """
    cooling_rate_filename = os.path.join(output_dir, f"cooling_rate_z{z}.txt")
    cooling_timescale_filename = os.path.join(output_dir, f"cooling_timescale_z{z}.txt")
    
    # Suppose cooling_rate_all has shape (len(T_list), len(initial_fH2_list))
    n_T = len(T_list)
    n_fH2 = len(initial_fH2_list)

    # Create new array with one extra row and column
    cooling_rate_with_labels = np.empty((n_T + 1, n_fH2 + 1))
    cooling_timescale_with_labels = np.empty((n_T + 1, n_fH2 + 1))

    # Fill in headers
    cooling_rate_with_labels[0, 0] = np.nan  # Top-left corner empty or NaN
    cooling_rate_with_labels[0, 1:] = initial_fH2_list  # First row = fH2
    cooling_rate_with_labels[1:, 0] = T_list    # First column = T
    cooling_rate_with_labels[1:, 1:] = cooling_rate_all  # Fill in data

    # Repeat for cooling timescale
    cooling_timescale_with_labels[0, 0] = np.nan
    cooling_timescale_with_labels[0, 1:] = initial_fH2_list
    cooling_timescale_with_labels[1:, 0] = T_list
    cooling_timescale_with_labels[1:, 1:] = cooling_timescale_all

    # Save to file
    np.savetxt(cooling_rate_filename, cooling_rate_with_labels, fmt="%.4e")
    np.savetxt(cooling_timescale_filename, cooling_timescale_with_labels, fmt="%.4e")
    """


def calculate_DF_heating_with_variance(z, lgM, variance_factors):

    heating_dict = {}
    
    if 0 in variance_factors:
        heating_dict[0] = integrate_SHMF_heating_for_single_host(z, -3, 0, lgM, "BestFit_z", mean_molecular_weight=mu_minihalo)
    
    variance_list = [f for f in variance_factors if f != 0]
    if variance_list:
        upper_rates, lower_rates, mean_rate = integrate_SHMF_heating_for_single_host_with_variance(
            z, -3, 0, lgM, "BestFit_z", variance_list, 'None', mean_molecular_weight=mu_minihalo)
        
        for i, factor in enumerate(variance_list):
            heating_dict[factor] = upper_rates[i]      # +nσ
            heating_dict[-factor] = lower_rates[i]     # -nσ
    return heating_dict


def plot_fH2_vs_T_with_DFvariance(z):

    output_dir = "/home/zwu/21cm_project/unified_model/Analytic_results/Yoshida03"

    #test different Hubble timescale
    t_Hubble_Tegmark = get_Hubble_timescale_Tegmark97(z)
    t_Hubble_colossus = cosmo.age(z)*1e3
    print(f"t_Hubble_Tegmark = {t_Hubble_Tegmark} Myr")
    print(f"t_Hubble_colossus = {t_Hubble_colossus} Myr")
    # t_Hubble_Myr = get_Hubble_timescale_Tegmark97(z)
    t_Hubble_Myr = t_Hubble_colossus
    # t_Hubble_Myr = 1.0/H0_s/Myr

    lognH = get_gas_lognH_analytic(z)
    # lognH = np.log10(500)
    print("lognH = ", lognH)
    nH = 10**lognH
    print("nH = ", nH)

    #plot fH2 vs T
    T_list = np.logspace(2, np.log10(1.1e4), 50)
    initial_fH2_list = np.logspace(-6, -1, 50)
    cooling_rate_for_initial_fH2 = np.zeros(len(initial_fH2_list))
    cooling_timescale_for_initial_fH2 = np.zeros(len(initial_fH2_list))
    cooling_timescale_all = np.zeros((len(T_list), len(initial_fH2_list)))
    cooling_rate_all = np.zeros((len(T_list), len(initial_fH2_list)))
    final_fH2_all = np.zeros((len(T_list), len(initial_fH2_list)))

    #first loop over T_list, then initial_fH2_list for debugging
    for i in range(len(T_list)):
        Tvir = T_list[i]
        print("Tvir = ", Tvir)
        for j in range(len(initial_fH2_list)):
            fH2 = initial_fH2_list[j]
            params_for_constdensity = {
                "evolve_cooling": False,
                "redshift": z,
                "lognH": lognH,
                "specific_heating_rate": 0.0,
                "volumetric_heating_rate": 0.0,
                "temperature": Tvir,
                "gas_metallicity": 0.0,
                "f_H2": fH2
            }
            cooling_data = run_constdensity_model(
                params_for_constdensity, UVB_flag=False, 
                Compton_Xray_flag=False, dynamic_final_flag=False, converge_when_setup=True)
            cooling_time = cooling_data['cooling_time']
            cooling_timescale_for_initial_fH2[j] = cooling_time.in_units('Myr')[0].v
            cooling_rate_for_initial_fH2[j] = cooling_data['cooling_rate'][0].v
            final_fH2_all[i, j] = cooling_data['H2I_density'][0].v/cooling_data['density'][0].v

        print("final_fH2 = ", final_fH2_all[i, :])
        print("cooling_timescale_for_initial_fH2 = ", cooling_timescale_for_initial_fH2)

        #interpolate cooling rate and cooling timescale as a function of final fH2
        sorted_indices = np.argsort(final_fH2_all[i, :])
        sorted_final_fH2 = final_fH2_all[i, :][sorted_indices]
        sorted_cooling_timescales = cooling_timescale_for_initial_fH2[sorted_indices]
        sorted_cooling_rates = cooling_rate_for_initial_fH2[sorted_indices]
        valid_mask = (
            (sorted_cooling_timescales < 0) &
            (sorted_cooling_rates < 0)
        )
        x = np.log10(sorted_final_fH2[valid_mask])
        y_timescale = np.log10(np.abs(sorted_cooling_timescales[valid_mask]))
        y_rate = np.log10(np.abs(sorted_cooling_rates[valid_mask]))
        interp_timescale_log = interp1d(x, y_timescale, bounds_error=False, fill_value=np.nan)
        interp_rate_log = interp1d(x, y_rate, bounds_error=False, fill_value=np.nan)

        log_fH2_targets = np.log10(np.array(initial_fH2_list))
        interpolated_timescale = 10 ** interp_timescale_log(log_fH2_targets)
        interpolated_rate = 10 ** interp_rate_log(log_fH2_targets)
        cooling_timescale_all[i, :] = -interpolated_timescale
        print("interpolated_timescale = ", -interpolated_timescale)
        cooling_rate_all[i, :] = -interpolated_rate
        print("interpolated_rate = ", -interpolated_rate)

    #include DF heating
    print("Calculating DF heating...")
    # sigma level
    variance_factors = [0, 1, 3]  # 0=mean, ±1σ, ±3σ
    scenario_labels = {0: 'mean', 1: '+1σ', -1: '-1σ', 3: '+3σ', -3: '-3σ'}

    print("Calculating DF heating with variance...")

    heating_results = {factor: np.zeros(len(T_list)) for factor in [0, 1, -1, 3, -3]}
    normalized_heating_results = {factor: np.zeros(len(T_list)) for factor in [0, 1, -1, 3, -3]}
    fH2_critical_results = {}



    for i in range(len(T_list)):
        Tvir = T_list[i]
        M_in_Msun = inversefunc_Temperature_Virial_analytic(Tvir, z, mean_molecular_weight=mu_minihalo)
        Mvir = M_in_Msun * h_Hubble
        lgM = np.log10(Mvir)
        
        # calculate DF heating for different variance factors
        heating_dict = calculate_DF_heating_with_variance(z, lgM, variance_factors)
        
        # convert to normalized heating density
        halo_density = get_mass_density_analytic(z)
        halo_volume = M_in_Msun * Msun / halo_density
        halo_volume_cm3 = halo_volume * 1.0e6
        
        for factor in [0, 1, -1, 3, -3]:
            if factor in heating_dict:
                DF_heating_erg = heating_dict[factor] * 1.0e7
                DF_heating_density = DF_heating_erg / halo_volume_cm3
                normalized_heating = DF_heating_density / nH**2
                
                heating_results[factor][i] = DF_heating_density
                normalized_heating_results[factor][i] = normalized_heating

    # calculate critical fH2 for each scenario
    for factor in [0, 1, -1, 3, -3]:
        if factor in normalized_heating_results:
            cooling_rate_with_DF_all = np.full((len(T_list), len(initial_fH2_list)), np.nan)
            cooling_timescale_with_DF_all = np.full((len(T_list), len(initial_fH2_list)), np.nan)
            
            for i in range(len(T_list)):
                for j in range(len(initial_fH2_list)):
                    cooling_rate = cooling_rate_all[i, j]
                    cooling_timescale = cooling_timescale_all[i, j]
                    
                    if not np.isnan(cooling_rate) and not np.isnan(cooling_timescale):
                        energy_density_in_cell = cooling_rate * cooling_timescale
                        cooling_rate_with_DF = cooling_rate + normalized_heating_results[factor][i]
                        cooling_rate_with_DF_all[i, j] = cooling_rate_with_DF
                        
                        if cooling_rate_with_DF != 0:
                            cooling_timescale_with_DF = energy_density_in_cell / cooling_rate_with_DF
                            cooling_timescale_with_DF_all[i, j] = cooling_timescale_with_DF
            
            # 计算critical fH2
            fH2_critical_results[factor] = find_critical_fH2(cooling_timescale_with_DF_all, initial_fH2_list, T_list, t_Hubble_Myr)

    print("DF heating calculation with variance completed.")
    fH2_critical = find_critical_fH2(cooling_timescale_all, initial_fH2_list, T_list, t_Hubble_Myr)


    #compare with H2 formed (Yoshida model)
    Tvir_fulllist = np.logspace(np.log10(100), np.log10(8000), 50) 

    z_final = 17
    # finalxe_zvir25 = finalxe_intTegmark_allresults[0]
    nHhalo_zfinal = get_nH_Tegmark97(z_final)
    fH2_Yoshida03 = get_fH2_Yoshida03(Tvir_fulllist)

    # fH2_Yoshida03_LWmax_shield = np.zeros(len(Tvir_fulllist))
    # fH2_Yoshida03_LWhigh = np.zeros(len(Tvir_fulllist))
    # fH2_Yoshida03_LWlow_shield = np.zeros(len(Tvir_fulllist))
    # fH2_Yoshida03_LWlow = np.zeros(len(Tvir_fulllist))
    LW_scenarios = [(0.01, False), (0.01, True), (1.0, True), (1.0e3, True)] #(J21, self_shielding)
    LW_labels = ['LW(J21 = 0.01)', 'LW(J21 = 0.01, ss', 
                 'LW(J21 = 1.0, ss)', 'LW(J21 = 1000, ss)']
    LW_colors = ['green', 'green', 'yellow', 'red']
    LW_linestyles = [':', '-.', '-.', '-.']
    fH2_Yoshida03_LW_allresults = np.zeros((len(LW_scenarios), len(Tvir_fulllist)))
    # for i, Tvir in enumerate(Tvir_fulllist):
    #     fH2_Yoshida03_LWmax[i] = get_H2_mass_frac_equilibrium(Tvir, None, z_final, 0.1, self_shielding=True)
    #     fH2_Yoshida03_LWhigh[i] = get_H2_mass_frac_equilibrium(Tvir, None, z_final, 1.0, self_shielding=False)
    #     fH2_Yoshida03_LWlow_shield[i] = get_H2_mass_frac_equilibrium(Tvir, None, z_final, 0.01, self_shielding=True)
    #     fH2_Yoshida03_LWlow[i] = get_H2_mass_frac_equilibrium(Tvir, None, z_final, 0.01, self_shielding=False)
    ss_model = "WG11"
    for i, (J21, self_shielding_flag) in enumerate(LW_scenarios):
        for j, Tvir in enumerate(Tvir_fulllist):
            fH2_Yoshida03_LW_allresults[i, j] = get_H2_mass_frac_equilibrium(
                Tvir, None, z_final, J21, self_shielding=self_shielding_flag, ss_model=ss_model
            )

    #LW results should not exceed fH2_Yoshida03(maximum)
    for i in range(len(LW_scenarios)):
        fH2_Yoshida03_LW_allresults[i, :] = np.minimum(fH2_Yoshida03_LW_allresults[i, :], fH2_Yoshida03[:])
    

    fig, ax1 = plt.subplots(figsize=(9, 7))
    ax1.plot(T_list, fH2_critical, label='No heating')
    ax1.plot(T_list, fH2_critical_results[0], label='Mean DF heating')

    # add variance bands
    ax1.fill_between(T_list, fH2_critical_results[-1], fH2_critical_results[1], 
                    alpha=0.3, label='±1σ SHMF DF heating')
    ax1.fill_between(T_list, fH2_critical_results[-3], fH2_critical_results[3], 
                    alpha=0.15, label='±3σ SHMF DF heating')

    ax1.plot(Tvir_fulllist, fH2_Yoshida03, label=r'$f_{H_2} \propto T^{1.52}$ (Yoshida 2003)', color='blue', linestyle='-')
    mask = (Tvir_fulllist > 200)
    # ax1.plot(Tvir_fulllist[mask], fH2_Yoshida03_LWhigh[mask], label='Yoshida 2003 LW(J21 = 0.1)', color='green', linestyle='--')
    # ax1.plot(Tvir_fulllist[mask], fH2_Yoshida03_LWlow_shield[mask], label='Yoshida 2003 LW(J21 = 0.01) with self-shielding', color='green', linestyle='-.')
    # ax1.plot(Tvir_fulllist[mask], fH2_Yoshida03_LWlow[mask], label='Yoshida 2003 LW(J21 = 0.01)', color='green', linestyle=':')
    for i, (J21, self_shielding_flag) in enumerate(LW_scenarios):
        ax1.plot(Tvir_fulllist[mask], fH2_Yoshida03_LW_allresults[i, mask], 
                 color=LW_colors[i], linestyle=LW_linestyles[i], label =LW_labels[i])

    ax1.set_xscale('log')
    ax1.set_yscale('log')
    # ax1.set_ylim(1e-7, 1e-1)
    ax1.set_xlabel('Temperature [K]', fontsize=15)
    ax1.set_ylabel('Molecular Hydrogen Fraction $f_{H_2}$', fontsize=15)
    ax1.legend(fontsize=12, loc='best', framealpha=0.5)
    #also add a mass axis on top
    ax2 = add_mass_axis_on_top(ax1, T_list, z, Tvir_to_lgM_minihalo, lgM_to_Tvir_minihalo)

    plt.title(f'Critical $f_{{H_2}}$ vs Temperature at z = {z}', fontsize=16)
    plt.tight_layout()
    plt.savefig(os.path.join(output_dir, f"fH2_vs_T_with_DFvariance_z{z}_WG11.png"), dpi=300)


def _iter_points_for_paper(paper, lgM_to_Tvir_minihalo):
    """
    Iterate over data points for a given paper configuration.

    Yields dicts with keys:
      'paper', 'marker', 'halo', 'j21', 'logJ', 'z', 'Tvir', 'fH2'

    Expected fields in `paper`:
      - 'store' (dict): dataset store (e.g., Latif2019_data).
      - 'halos' (list[str]): halo names to include.
      - 'r_range_in_R200_unit' (list[float], optional): [r_min, r_max] in units of R200.
      - 'r_range_in_native_unit' (list[float], optional): [r_min, r_max] in the store's native radius unit.
      - 'marker' (str, optional): Matplotlib marker for this paper (default: 'o').
      - 'name' (str, optional): display name for the paper (default: 'paper').

    Optional filters:
      - 'j21_by_halo' (dict[str, list[float]]): restrict allowed J21 per halo.
      - 'target_z' (float): target collapse redshift to filter around.
      - 'z_tol' (float): keep only entries with |z - target_z| <= z_tol.
      - 'pick_nearest_to_z' (bool): if True and target_z is given (without z_tol),
        pick the single J21 per halo whose z is closest to target_z.
    """
    store   = paper["store"]
    halos   = paper["halos"]
    r_range_r200 = paper.get("r_range_in_R200_unit", None)
    r_range_native = paper.get("r_range_in_native_unit", None)
    Mgas_frac_range = paper.get("Mgas_frac_range", None)
    marker  = paper.get("marker", "o")
    pname   = paper.get("name", "paper")
    print("pname =", pname)

    j21_by_halo       = paper.get("j21_by_halo", None)
    target_z          = paper.get("target_z", None)
    z_tol             = paper.get("z_tol", None)
    pick_nearest_to_z = bool(paper.get("pick_nearest_to_z", False))

    for halo in halos:



        print(f"collecting halo {halo} data in paper {pname}...")
        if pname == "Wise2019":
            j_all = sorted([k for k in store[halo].keys() if isinstance(k, (float, int))])
        else:
            j_density = set(store[halo].get("density", {}).keys())
            j_fh2     = set(store[halo].get("fH2", {}).keys())
            j_scalar  = {k for k in store[halo].keys() if isinstance(k, (float, int))}
            j_all     = sorted(j_density & j_fh2 & j_scalar, key=float)

        
        # Candidate J21s: intersection of available density, fH2, and scalar blocks
        j_density = set(store[halo].get("density", {}).keys())
        j_fh2     = set(store[halo].get("fH2",     {}).keys())
        j_scalar  = {k for k in store[halo].keys() if isinstance(k, (float, int))}
        j_all     = sorted(j_density & j_fh2 & j_scalar, key=float)

        # Exact J21 selection per halo (if provided)
        if j21_by_halo and halo in j21_by_halo:
            allowed = {float(x) for x in j21_by_halo[halo]}
            j_all = [float(j) for j in j_all if float(j) in allowed]

        if not j_all:
            continue

        # If filtering by target redshift, pre-read z and M per J21
        if target_z is not None:
            pairs = []
            for j in j_all:
                sc = store[halo][float(j)]
                z  = sc.get("z_collapse", None)
                M  = sc.get("M_collapse_Msun", None)
                if z is None or M is None:
                    continue
                pairs.append((float(j), float(z), float(M)))
            if not pairs:
                continue

            if z_tol is not None:
                pairs = [(j, z, M) for (j, z, M) in pairs if abs(z - target_z) <= z_tol]
                if not pairs:
                    continue
                j_all = [j for (j, _, _) in pairs]
                z_by_j = {j: z for (j, z, _) in pairs}
                M_by_j = {j: M for (j, _, M) in pairs}
            elif pick_nearest_to_z:
                j, z, M = min(pairs, key=lambda t: abs(t[1] - target_z))
                j_all   = [j]
                z_by_j  = {j: z}
                M_by_j  = {j: M}
            else:
                z_by_j = {j: z for (j, z, _) in pairs}
                M_by_j = {j: M for (j, _, M) in pairs}
        else:
            z_by_j, M_by_j = {}, {}

        for j in j_all:
            # Scalars (read now if not pre-read)
            z = z_by_j.get(j)
            M = M_by_j.get(j)
            if z is None or M is None:
                sc = store[halo][float(j)]
                z  = sc.get("z_collapse", None)
                M  = sc.get("M_collapse_Msun", None)
                if z is None or M is None:
                    continue

            # Virial temperature
            Tvir = lgM_to_Tvir_minihalo(np.log10(M * h_Hubble), z)

            # Mass-weighted fH2 over [r_min, r_max] in the store's native radius unit
            #set floor according to paper
            if pname == "Latif2014A":
                fH2_floor = 1.0e-8
            else:
                fH2_floor = 1.0e-7

            print("pname =", pname)
            if pname == "Wise2019": #use Mgas integral
                print("  Using Mgas-weighted fH2...")
                j_key = float(j)
                if Mgas_frac_range is not None:
                    Mgas_min = Mgas_frac_range[0] * M
                    Mgas_max = Mgas_frac_range[1] * M
                else:
                    raise ValueError("Missing Mgas_frac_range in paper config.")
                res = latif.mass_weighted_fH2_from_fH2_vs_Mgas(
                    halo=halo, j21=float(j),
                    M_min=Mgas_min, M_max=Mgas_max,
                    fH2_floor=fH2_floor, store=store
                )
                fH2_extrap = store[halo][j_key].get("fH2_extrap_factor", 0.0)
                rho_extrap = 0.0  # not used for Wise2019
                print(f"  (fH2_extrap, rho_extrap) = ({fH2_extrap}, {rho_extrap})")

            else:
                print("  Using density-weighted fH2...")

                j_key = float(j)
                r200 = store[halo][j_key].get("R200", None)
                if r_range_r200 is not None:
                    if r200 is None:
                        continue
                    r_min = r_range_r200[0] * r200
                    r_max = r_range_r200[1] * r200
                elif r_range_native is not None:
                    r_min, r_max = r_range_native
                else:
                    raise ValueError("Missing r_range_in_R200_unit or r_range_in_native_unit in paper config.")

        
                res = latif.mass_weighted_fH2(
                    halo, float(j),
                    r_min=r_min, r_max=r_max,
                    n_samples=1000, fH2_floor=fH2_floor,
                    store=store
                )

                fH2_extrap = store[halo][j_key].get("fH2_extrap_factor", 0.0)
                rho_extrap = store[halo][j_key].get("density_extrap_factor", 0.0)
                print(f"  (fH2_extrap, rho_extrap) = ({fH2_extrap}, {rho_extrap})")

            formation_mode = store[halo][j_key].get("formation_mode", "PopIII")

            yield {
                "paper":  pname,
                "marker": marker,
                "halo":   halo,
                "j21":    float(j),
                "logJ":   np.log10(float(j)),
                "z":      float(z),
                "Tvir":   float(Tvir),
                "fH2":    float(res["fH2_avg"]),
                "fH2_extrap": float(fH2_extrap),
                "rho_extrap": float(rho_extrap),
                "formation_mode": formation_mode,
            }
            print(f"  J21={j:.3g}, z={z:.2f}, M={M:.2e} Msun, Tvir={Tvir:.1f} K, fH2={res['fH2_avg']:.3e}")


def plot_Tvir_vs_fH2_by_paper(papers,
                              lgM_to_Tvir_minihalo,
                              annotate="all",  # "all" 或 "extremes"
                              fH2_ylim=(1e-8, 1e-2),
                              ax=None, cmap="viridis"):
    # gather all points
    rows = []
    for paper in papers:
        rows.extend(list(_iter_points_for_paper(paper, lgM_to_Tvir_minihalo)))

    skip_extrapolated = False
    if skip_extrapolated:
        rows = [
            r for r in rows
            if r["rho_extrap"] <= 1.0
            # if r["fH2_extrap"] <= 1.0 and r["rho_extrap"] <= 1.0
        ]


    if not rows:
        raise ValueError("No points to plot. Check that stores contain density/fH2 profiles and collapse scalars.")

    if ax is None:
        fig, ax = plt.subplots(figsize=(8.5, 6.5))
    else:
        fig = ax.figure

    # color: log10(J21)
    logJ_all = np.array([r["logJ"] for r in rows])
    norm = Normalize(vmin=np.min(logJ_all), vmax=np.max(logJ_all))
    cmap_obj = plt.get_cmap(cmap)

    # plot points, one paper at a time (for consistent markers)
    paper_to_marker = {p["name"]: p.get("marker", "o") for p in papers}
    paper_order = [p["name"] for p in papers]

    for p_name in paper_order:

        p_name_ext = p_name
        if p_name == "Latif2019":
            p_name_ext += " (Trad = 2e4 K)"
        elif p_name == "Latif2021":
            p_name_ext += " (Trad = 1e5 K)"
        elif p_name == "Latif2014A":
            p_name_ext += " (Trad = 1e4 K)"
        elif p_name == "Latif2015_2e4K":
            p_name_ext = "Latif2015 (Trad = 2e4 K)"

        sub = [r for r in rows if r["paper"] == p_name]
        if not sub: continue
        DCBH_points = [r for r in sub if r.get("formation_mode") == "DCBH"]
        PopIII_points = [r for r in sub if r.get("formation_mode") == "PopIII"]

        def extract_arrays(rows):
            return (
                np.array([r["Tvir"] for r in rows]),
                np.array([r["fH2"] for r in rows]),
                np.array([r["logJ"] for r in rows])
            )
        # PopIII points (black edge)
        T_pop, f_pop, c_pop = extract_arrays(PopIII_points)
        ax.scatter(T_pop, f_pop,
                c=c_pop, cmap=cmap_obj, norm=norm,
                marker=paper_to_marker[p_name],
                s=80, edgecolor="black", linewidths=0.6, alpha=0.9, label=p_name_ext)

        # DCBH candidates (red edge highlight)
        T_dcbh, f_dcbh, c_dcbh = extract_arrays(DCBH_points)
        ax.scatter(T_dcbh, f_dcbh,
                c=c_dcbh, cmap=cmap_obj, norm=norm,
                marker=paper_to_marker[p_name],
                s=80, edgecolor="red", linewidths=1.2, alpha=0.9)

        # annotate redshifts for points
        if annotate == "all":
            for r in sub:
                ax.annotate(f"z={r['z']:.1f}", (r["Tvir"], r["fH2"]),
                            textcoords="offset points", xytext=(4, 4),
                            ha="left", va="bottom", fontsize=8, alpha=0.8)
        elif annotate == "extremes":
            # only annotate min and max z
            zs = np.array([r["z"] for r in sub])
            idxs = [int(np.argmin(zs)), int(np.argmax(zs))]
            for i in idxs:
                r = sub[i]
                ax.annotate(f"z={r['z']:.1f}", (r["Tvir"], r["fH2"]),
                            textcoords="offset points", xytext=(4, 4),
                            ha="left", va="bottom", fontsize=8, alpha=0.9, fontweight="bold")

    ax.set_xscale("log")
    ax.set_yscale("log")
    if fH2_ylim is not None:
        ax.set_ylim(fH2_ylim)
    ax.set_xlabel("Temperature [K]", fontsize=13)
    ax.set_ylabel("Molecular Hydrogen Fraction $f_{\\mathrm{H}_2}$", fontsize=13)

    # show legend
    leg = ax.legend(title="Paper", fontsize=11, framealpha=0.6, loc="best")
    leg._legend_box.align = "left"

    # color bar: log10 J21
    sm = ScalarMappable(norm=norm, cmap=cmap_obj)
    sm.set_array([])
    cbar = fig.colorbar(sm, ax=ax, pad=0.02)
    cbar.set_label(r"$\log_{10} J_{21}$", rotation=90)

    # ax.grid(True, which="both", ls="--", lw=0.5, alpha=0.5)

    # Add annotation: PopIII collapse (upward arrow)
    ax.annotate("Collapse to form PopIII stars",
                xy=(1e3, 1e-4),          # arrow pointing position
                xytext=(1e3, 1e-5),     # text position (arrow start)
                arrowprops=dict(arrowstyle="->", color="black", lw=1.5),
                fontsize=11,
                ha="center")

    # Add annotation: Grow to DCBH (right arrow)
    ax.annotate("Grow to DCBH candidate",
                xy=(4e3, 1e-7),          # arrow pointing position
                xytext=(1e3, 1e-7),      # text position (arrow start)
                arrowprops=dict(arrowstyle="->", color="black", lw=1.5),
                fontsize=11,
                va="center")


    return fig, ax


def plot_fH2_vs_T_from_SHMF_sampling(z):

    output_dir = "/home/zwu/21cm_project/unified_model/Analytic_results/Yoshida03"

    #test different Hubble timescale
    t_Hubble_Tegmark = get_Hubble_timescale_Tegmark97(z)
    t_Hubble_colossus = cosmo.age(z)*1e3
    print(f"t_Hubble_Tegmark = {t_Hubble_Tegmark} Myr")
    print(f"t_Hubble_colossus = {t_Hubble_colossus} Myr")
    # t_Hubble_Myr = get_Hubble_timescale_Tegmark97(z)
    t_Hubble_Myr = t_Hubble_colossus
    # t_Hubble_Myr = 1.0/H0_s/Myr

    lognH = get_gas_lognH_analytic(z)
    # lognH = np.log10(500)
    print("lognH = ", lognH)
    nH = 10**lognH
    print("nH = ", nH)

    #plot fH2 vs T

    converge_when_setup = False
    if converge_when_setup:
        results_file = os.path.join(output_dir, f"critical_fH2_results_z{z}.npz")
    else:
        results_file = os.path.join(output_dir, f"critical_fH2_results_noconverge_z{z}.npz") #converge_when_setup=False


    use_precomputed_results = True

    if os.path.exists(results_file) and use_precomputed_results:
        print(f"Loading precomputed results from {results_file} ...")
        data = np.load(results_file)
        T_list = data['T_list']
        fH2_critical = data['fH2_critical']
        fH2_critical_mean = data['fH2_critical_mean']
        fH2_critical_p16 = data['fH2_critical_p16']
        fH2_critical_p84 = data['fH2_critical_p84']
        fH2_critical_p025 = data['fH2_critical_p025']
        fH2_critical_p975 = data['fH2_critical_p975']
        fH2_critical_p0015 = data['fH2_critical_p0015']
        fH2_critical_p9985 = data['fH2_critical_p9985']
    else:
        print("Running full calculation...")

        T_list = np.logspace(2, np.log10(10000), 50)
        initial_fH2_list = np.logspace(-6, -1, 100)
        target_fH2_list = np.logspace(-6, -1, 100)
        log_fH2_targets = np.log10(target_fH2_list)
        cooling_rate_for_initial_fH2 = np.zeros(len(initial_fH2_list))
        cooling_timescale_for_initial_fH2 = np.zeros(len(initial_fH2_list))
        final_fH2_all = np.zeros((len(T_list), len(initial_fH2_list)))

        cooling_timescale_all = np.zeros((len(T_list), len(target_fH2_list)))
        cooling_rate_all = np.zeros((len(T_list), len(target_fH2_list)))

        #first loop over T_list, then initial_fH2_list 
        for i in range(len(T_list)):
            Tvir = T_list[i]
            print("Tvir = ", Tvir)
            for j in range(len(initial_fH2_list)):
                fH2 = initial_fH2_list[j]
                params_for_constdensity = {
                    "evolve_cooling": False,
                    "redshift": z,
                    "lognH": lognH,
                    "specific_heating_rate": 0.0,
                    "volumetric_heating_rate": 0.0,
                    "temperature": Tvir,
                    "gas_metallicity": 0.0,
                    "f_H2": fH2
                }
                cooling_data = run_constdensity_model(
                    params_for_constdensity, UVB_flag=False, 
                    Compton_Xray_flag=False, dynamic_final_flag=False, converge_when_setup=converge_when_setup)
                cooling_time = cooling_data['cooling_time']
                cooling_timescale_for_initial_fH2[j] = cooling_time.in_units('Myr')[0].v
                cooling_rate_for_initial_fH2[j] = cooling_data['cooling_rate'][0].v
                final_fH2_all[i, j] = cooling_data['H2I_density'][0].v/cooling_data['density'][0].v

            print("final_fH2 = ", final_fH2_all[i, :])
            print("cooling_timescale_for_initial_fH2 = ", cooling_timescale_for_initial_fH2)

            #interpolate cooling rate and cooling timescale as a function of final fH2
            sorted_indices = np.argsort(final_fH2_all[i, :])
            sorted_final_fH2 = final_fH2_all[i, :][sorted_indices]
            sorted_cooling_timescales = cooling_timescale_for_initial_fH2[sorted_indices]
            sorted_cooling_rates = cooling_rate_for_initial_fH2[sorted_indices]
            valid_mask = (
                (sorted_cooling_timescales < 0) &
                (sorted_cooling_rates < 0)
            )
            x = np.log10(sorted_final_fH2[valid_mask])
            y_timescale = np.log10(np.abs(sorted_cooling_timescales[valid_mask]))
            y_rate = np.log10(np.abs(sorted_cooling_rates[valid_mask]))
            interp_timescale_log = interp1d(x, y_timescale, bounds_error=False, fill_value=np.nan)
            interp_rate_log = interp1d(x, y_rate, bounds_error=False, fill_value=np.nan)

            interpolated_timescale = 10 ** interp_timescale_log(log_fH2_targets)
            interpolated_rate = 10 ** interp_rate_log(log_fH2_targets)
            cooling_timescale_all[i, :] = -interpolated_timescale
            print("interpolated_timescale = ", -interpolated_timescale)
            cooling_rate_all[i, :] = -interpolated_rate
            print("interpolated_rate = ", -interpolated_rate)

        #include DF heating
        print("Calculating DF heating and critical fH2 from SHMF sampling...")

        n_samples = 500
        fH2_critical_all_samples = np.full((n_samples, len(T_list)), np.nan)

        for i in range(len(T_list)):
            Tvir = T_list[i]
            M_in_Msun = inversefunc_Temperature_Virial_analytic(Tvir, z, mean_molecular_weight=mu_minihalo)
            Mvir = M_in_Msun * h_Hubble
            lgM = np.log10(Mvir)
            lgx_min = -4
            lgx_max = 0
            SHMF_model = "BestFit_z"

            heating_of_samples = integrate_SHMF_heating_for_single_host_PoissonSampling(z, 
                                lgx_min, lgx_max, lgM, SHMF_model, n_samples, mean_molecular_weight=mu_minihalo, verbose=False)


            # convert to normalized heating density
            halo_density = get_mass_density_analytic(z)
            halo_volume = M_in_Msun * Msun / halo_density
            halo_volume_cm3 = halo_volume * 1.0e6
            DF_heating_erg = heating_of_samples * 1.0e7
            DF_heating_density = DF_heating_erg / halo_volume_cm3
            normalized_heating = DF_heating_density / nH**2


            # Calculate critical fH2 for each sample
            for sample_idx in range(n_samples):
                current_heating = normalized_heating[sample_idx]
                
                cooling_rate_with_DF_all = np.full((len(T_list), len(initial_fH2_list)), np.nan)
                cooling_timescale_with_DF_all = np.full((len(T_list), len(initial_fH2_list)), np.nan)
                
                # Only need to calculate for current temperature i
                for j in range(len(initial_fH2_list)):
                    cooling_rate = cooling_rate_all[i, j]
                    cooling_timescale = cooling_timescale_all[i, j]
                    
                    if not np.isnan(cooling_rate) and not np.isnan(cooling_timescale):
                        energy_density_in_cell = cooling_rate * cooling_timescale
                        cooling_rate_with_DF = cooling_rate + current_heating
                        cooling_rate_with_DF_all[i, j] = cooling_rate_with_DF
                        
                        if cooling_rate_with_DF != 0:
                            cooling_timescale_with_DF = energy_density_in_cell / cooling_rate_with_DF
                            cooling_timescale_with_DF_all[i, j] = cooling_timescale_with_DF
                
                # Calculate critical fH2 for current sample at current temperature
                fH2_critical = find_critical_fH2(cooling_timescale_with_DF_all, initial_fH2_list, T_list, t_Hubble_Myr)
                fH2_critical_all_samples[sample_idx, i] = fH2_critical[i]  # Only take current temperature value

        # Statistical analysis
        fH2_critical_mean = np.mean(fH2_critical_all_samples, axis=0)
        fH2_critical_std = np.std(fH2_critical_all_samples, axis=0)
        fH2_critical_median = np.median(fH2_critical_all_samples, axis=0)
        # 1, 2, 3 sigma equivalent percentiles
        fH2_critical_p16, fH2_critical_p84 = np.percentile(fH2_critical_all_samples, [16, 84], axis=0)
        fH2_critical_p025, fH2_critical_p975 = np.percentile(fH2_critical_all_samples, [2.5, 97.5], axis=0)
        fH2_critical_p0015, fH2_critical_p9985 = np.percentile(fH2_critical_all_samples, [0.15, 99.85], axis=0)
        print("DF heating calculation with random sampling completed.")

        fH2_critical = find_critical_fH2(cooling_timescale_all, initial_fH2_list, T_list, t_Hubble_Myr)
        # Save results to file
        np.savez(results_file,
            T_list=T_list,
            fH2_critical=fH2_critical,
            fH2_critical_mean=fH2_critical_mean,
            fH2_critical_p16=fH2_critical_p16,
            fH2_critical_p84=fH2_critical_p84,
            fH2_critical_p025=fH2_critical_p025,
            fH2_critical_p975=fH2_critical_p975,
            fH2_critical_p0015=fH2_critical_p0015,
            fH2_critical_p9985=fH2_critical_p9985)
        print(f"Results saved to {results_file}")

    #compare with H2 formed (Yoshida model)
    Tvir_fulllist = np.logspace(np.log10(100), np.log10(10000), 50) 

    # z_final = 17
    # finalxe_zvir25 = finalxe_intTegmark_allresults[0]
    # nHhalo_zfinal = get_nH_Tegmark97(z_final)
    fH2_Yoshida03 = get_fH2_Yoshida03(Tvir_fulllist)


    fig, ax1 = plt.subplots(figsize=(9, 7))
    ax1.plot(Tvir_fulllist, fH2_Yoshida03, label=r'$f_{H_2} \propto T^{1.52}$ (Yoshida03)', color='dimgrey', linestyle='--')
 
    ax1.plot(T_list, fH2_critical, color = 'k', label='No heating')
    ax1.plot(T_list, fH2_critical_mean, color = 'r', label='Mean DF heating')  
    ax1.fill_between(T_list, fH2_critical_p16, fH2_critical_p84, 
                     alpha=0.4, color = 'orange', label='16/84 %')
    ax1.fill_between(T_list, fH2_critical_p025, fH2_critical_p975,
                        alpha=0.2, color = 'orange', label='2.5/97.5 %')
    ax1.fill_between(T_list, fH2_critical_p0015, fH2_critical_p9985,
                        alpha=0.1, color = 'orange', label='0.15/99.85 %')
    
    papers = [
        dict(name="Latif2014A",
            store=latif.Latif2014A_data,
            halos=["haloA","haloB","haloC","haloD","haloE"],
            marker="s",
            r_range_in_R200_unit = [1.0e-5, 1.0], # in units of R200
            # r_range_in_native_unit = [1.0e3, 2.0e6]       # au
            # j21_by_halo={"halo6":[10,1000], "halo1":[5,10,50]}
            ),

        dict(name="Latif2015_2e4K",
            store=latif.Latif2015_2e4K_data,
            halos=["haloA","haloB","haloC"],
            marker="D",
            r_range_in_R200_unit = [1.0e-5, 1.0], # in units of R200
            # r_range_in_native_unit = [1.0e3, 2.0e6]       # au
            ),
        dict(name="Latif2019",
            store=latif.Latif2019_data,
            halos=["halo1","halo6"],
            marker="o",
            r_range_in_R200_unit = [1.0e-5, 1.0] # in units of R200
            # r_range_in_native_unit = [1.0e-3, 1.0e3]       # pc
            ),
        dict(name="Latif2021",
            store=latif.Latif2021_data,
            halos=["halo1","halo2","halo3","halo4","halo5","halo6"],
            marker="^",
            r_range_in_R200_unit = [1.0e-5, 1.0], # in units of R200
            # r_range_in_native_unit = [3e-2, 2e2]      # pc
            ),
        dict(name="Wise2019",
            store=latif.Wise2019_data,   
            halos=["MMH", "LWH"],      
            marker="*",                 
            Mgas_frac_range=[1.0e-5*(Omega_b/Omega_m), (Omega_b/Omega_m)],  
        ),          
    ]


    plot_Tvir_vs_fH2_by_paper(
        papers,
        lgM_to_Tvir_minihalo=lgM_to_Tvir_minihalo,
        annotate="all",   # or "extremes" to only annotate min/max z per halo
        ax = ax1,
        fH2_ylim=(1e-9, 1e-2),
    )

        
    ax1.set_xscale('log')
    ax1.set_yscale('log')
    ax1.set_ylim(top = 1e-2)
    ax1.set_xlabel('Tvir [K]', fontsize=15)
    ax1.set_ylabel('Molecular Hydrogen Fraction $f_{H_2}$', fontsize=15)
    ax1.legend(fontsize=12, loc='lower left', framealpha=0.5)
    #also add a mass axis on top
    ax2 = add_mass_axis_on_top(ax1, T_list, z, Tvir_to_lgM_minihalo, lgM_to_Tvir_minihalo)

    # plt.title(f'Critical $f_{{H_2}}$ vs Temperature at z={z} (SHMF Poisson Sampling), nH: core profile', fontsize=16)
    plt.title(f'Critical $f_{{H_2}}$ vs Temperature at z={z}', fontsize=16)
    
    plt.tight_layout()
    # filename = os.path.join(output_dir, f"fH2_vs_T_from_SHMF_sampling_z{z}_nHLW{nH}.png")
    noconverge_tag = "" if converge_when_setup else "noconverge_"
    filename = os.path.join(output_dir, f"fH2_vs_T_from_SHMF_sampling_z{z}_{noconverge_tag}.png")
    
    plt.savefig(filename, dpi=300)
    print("plot saved to ", filename)
                
    
#dynamical heating in Yoshida03, Wise19    
def get_critical_mass_accretion_rate(z, Mhalo, fH2):
    """
    Mhalo: [Msun/h]
    fH2: H2 mass fraction
    """
    lgM = np.log10(Mhalo)
    Tvir = lgM_to_Tvir_minihalo(lgM,z)
    lognH = get_gas_lognH_analytic(z)
    nH = 10**lognH
    params_for_constdensity = {
        "evolve_cooling": False,
        "redshift": z,
        "lognH": lognH,
        "specific_heating_rate": 0.0,
        "volumetric_heating_rate": 0.0,
        "temperature": Tvir,
        "gas_metallicity": 0.0,
        "f_H2": fH2
    }
    cooling_data = run_constdensity_model(
        params_for_constdensity, UVB_flag=False, 
        Compton_Xray_flag=False, dynamic_final_flag=False, converge_when_setup=False)
    # cooling_time = cooling_data['cooling_time'].in_units('Myr')[0].v
    # print(cooling_data['cooling_rate'])
    cooling_rate = cooling_data['cooling_rate'][0].v # [erg*cm^3/s]
    volumetric_cooling = nH **2 * cooling_rate #[erg/cm^3/s]
    crit_volumetric_heating = abs(volumetric_cooling)

    #also consider the species equilibrium case, so that atomic cooling is included
    cooling_data_species_eq = run_constdensity_model(
        params_for_constdensity, UVB_flag=False, 
        Compton_Xray_flag=False, dynamic_final_flag=True, converge_when_setup=True)
    cooling_rate_species_eq = cooling_data_species_eq['cooling_rate'][0].v  # [erg*cm^3/s]
    volumetric_cooling_species_eq = nH **2 * cooling_rate_species_eq #[erg/cm^3/s]
    crit_volumetric_heating_species_eq = abs(volumetric_cooling_species_eq)

    crit_volumetric_heating = max(crit_volumetric_heating, crit_volumetric_heating_species_eq)  # [erg/cm^3/s]

    gamma_adiabatic = 5.0/3.0
    dT_dt_crit = (1.0e-7* crit_volumetric_heating) /nH/kB * (gamma_adiabatic - 1.0) #[K/s]
    
    delta_lgM = 1e-3 * lgM
    dT_dlgM = (lgM_to_Tvir_minihalo(lgM + delta_lgM, z) - lgM_to_Tvir_minihalo(lgM - delta_lgM, z))/ (2.0 * delta_lgM)
    dT_dM = dT_dlgM / (np.log(10) * Mhalo)  # [K/(Msun/h)]    
    dM_dT = 1.0 / dT_dM  # [Msun/h/K]
    dM_dt_crit = dM_dT * dT_dt_crit  # [Msun/h/s]
    dM_dt_crit_yr = dM_dt_crit * (365.25 * 24 * 3600)  # [Msun/h/yr]
    Hz = cosmo.Hz(z)/3.086e19  #convert km/s/Mpc to s^(-1)
    dt_dz = -1/(1+z)/Hz
    dM_dz_crit = dM_dt_crit * dt_dz  # [Msun/h]


    return {
        # "cooling_time": cooling_time,  # [Myr]
        # "cooling_rate": cooling_rate,  # [erg*cm^3/s]
        # "volumetric_cooling": volumetric_cooling,  # [erg/cm^3/s]
        "dM_dt_crit": abs(dM_dt_crit),  # [Msun/h/s]
        "dM_dt_crit_yr": abs(dM_dt_crit_yr),  # [Msun/h/yr]
        "dM_dz_crit": abs(dM_dz_crit)  # [Msun/h]
    }

def plot_critical_mass_accretion_rate():
    output_dir = "/home/zwu/21cm_project/unified_model/Analytic_results/Yoshida03"
    #1. Figure 5 of Yoshida03 (almost the same)
    
    z = 18
    Mhalo_list = np.logspace(5, 7, 50)  # [Msun/h]
    Tvir_list = np.array([lgM_to_Tvir_minihalo(np.log10(Mhalo), z) for Mhalo in Mhalo_list])
    fH2_list = np.array([get_fH2_Yoshida03(Tvir) for Tvir in Tvir_list])
    dM_dz_crit_list = np.array([get_critical_mass_accretion_rate(z, Mhalo, fH2)['dM_dz_crit']
                                 for Mhalo, fH2 in zip(Mhalo_list, fH2_list)])
    
    fig, ax = plt.subplots(figsize=(9, 7))
    ax.plot(Mhalo_list, dM_dz_crit_list, label=f'z = {z}', color='grey')
    ax.set_xscale('log')
    ax.set_yscale('log')
    ax.set_ylim(1e5, 5e6)
    ax.set_xlabel('Halo Mass [Msun/h]', fontsize=15)
    ax.set_ylabel('Critical accretion dM/dz [Msun/h]', fontsize=15)
    ax.legend()
    plt.tight_layout()
    filename = os.path.join(output_dir, f"critical_accretion_Yoshida03_z{z}.png")
    plt.savefig(filename, dpi=300)
    print("saved critical accretion plot to ", filename)
    

    #2. Extended Data Figure 1 of Wise19
    z = 25
    y_H2_list = np.array([1e-4, 1e-5, 1e-6]) #H2 abundance
    f_H2_list = 2 * y_H2_list  #H2 mass fraction
    Mhalo_Msun_list = np.logspace(np.log10(4e5), 8, 50)  # [Msun]
    Mhalo_list = Mhalo_Msun_list * h_Hubble  # [Msun/h]
    all_results = []
    for i, f_H2 in enumerate(f_H2_list):
        dM_dz_crit_list = []
        for Mhalo in Mhalo_list:
            result = get_critical_mass_accretion_rate(z, Mhalo, f_H2)
            dM_dz_crit_list.append(result['dM_dz_crit'])
        all_results.append(dM_dz_crit_list)    
    #convert from [dMsun/h/dz] to [dMsun/dz]
    all_results = np.array(all_results)  
    all_results /= h_Hubble 

    colors = ['blue','orange', 'green']
    fig, ax = plt.subplots(figsize=(9, 7))
    for i, y_H2 in enumerate(y_H2_list):
        ax.plot(Mhalo_Msun_list, all_results[i], label=f'n(H2)/nH = {y_H2}', color=colors[i])
    ax.set_xscale('log')
    ax.set_yscale('log')
    ax.set_ylim(1e5, 5e8)
    ax.set_xlabel('Halo Mass [Msun]', fontsize=15)
    ax.set_ylabel('Critical accretion dM/dz [Msun]', fontsize=15)
    ax.legend()
    plt.title(f'Critical Accretion Rate at z = {z}', fontsize=16)
    plt.tight_layout()
    filename = os.path.join(output_dir, f"critical_accretion_Wise19_z{z}.png")
    plt.savefig(filename, dpi=300)
    print("saved critical accretion Wise19 plot to ", filename)




if __name__ == "__main__":
    # compare_Hubble_timescale_and_nH()
    # test_Tvir()
    # test_fH2_scaling()
    # test_k1()
    # test_Tegmark_model()


    # plot_xefH2_vs_z()
    # test_H2_form_diss_timescale()
    # plot_Yoshida03_fH2_vs_Tvir()
    # plot_fH2_vs_T(z = 15)
    plot_fH2_vs_T_from_SHMF_sampling(z = 15)


    # get_critical_mass_accretion_rate(z=18, Mhalo=1e6, fH2=1e-5)
    # plot_critical_mass_accretion_rate()

    # get_H2_mass_frac_eq_fromprofile(7000, 15, 10, 'T4')